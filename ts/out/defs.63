and(l_q(,MUDDLE
    100);
  use("LSRTNS"););

// applicables

newtype(OFFSET
  WORD);

put(RAPPLIC
  DECL
  'or(ATOM
      FALSE
      OFFSET););

// newtypes for parser

newtype(BUZZ
  STRING);

newtype(DIRECTION
  ATOM);

newtype(ADJECTIVE
  ATOM);

newtype(PREP
  ATOM);

\

// generalized oflags tester

defmac(TRNN
  ('OBJ
    'BIT)
  form(N==?
    form(CHTYPE
      form(ANDB
        .BIT
        form(OFLAGS
          .OBJ););
      FIX);
    0););

defmac(RTRNN
  ('RM
    'BIT)
  form(N==?
    form(CHTYPE
      form(ANDB
        .BIT
        form(RBITS
          .RM););
      FIX);
    0););

defmac(RTRZ
  ('RM
    'BIT)
  form(PUT
    .RM
    ,RBITS
    form(ANDB
      form(RBITS
        .RM);
      form(XORB
        .BIT
        -1););););

defmac(TRC
  ('OBJ
    'BIT)
  form(PUT
    .OBJ
    ,OFLAGS
    form(XORB
      form(OFLAGS
        .OBJ);
      .BIT);););

defmac(TRZ
  ('OBJ
    'BIT)
  form(PUT
    .OBJ
    ,OFLAGS
    form(ANDB
      form(OFLAGS
        .OBJ);
      form(XORB
        .BIT
        -1););););

defmac(TRO
  ('OBJ
    'BIT)
  form(PUT
    .OBJ
    ,OFLAGS
    form(ORB
      form(OFLAGS
        .OBJ);
      .BIT);););

defmac(RTRO
  ('RM
    'BIT)
  form(PUT
    .RM
    ,RBITS
    form(ORB
      form(RBITS
        .RM);
      .BIT);););

\

// room definition

newstruc(ROOM
  VECTOR
  RID
  ATOM
  // room id
  RDESC1
  STRING
  // long description
  RDESC2
  STRING
  // short description
  RSEEN?
  or(ATOM
    FALSE);
  // visited?
  RLIGHT?
  or(ATOM
    FALSE);
  // endogenous light source?
  REXITS
  EXIT
  // list of exits
  ROBJS
  list([REST
      OBJECT]);
  // objects in room
  RACTION
  RAPPLIC
  // room-action
  RVARS
  primtype(WORD);
  // slot for use of room function
  RVAL
  FIX
  // value for visiting
  RBITS
  primtype(WORD);
  // random flags
  RRAND
  ANY
  // random slot);

// flagword for <RBITS room>:    bit-name   bit-tester

flagword(RLANDBIT
  <>
  // on land
  RWATERBIT
  <>
  // water room
  RAIRBIT
  <>
  // mid-air room
  RSACREDBIT
  <>
  // thief not allowed
  RFILLBIT
  <>
  // can fill bottle here
  RMUNGBIT
  <>
  // room has been munged
  RBUCKBIT
  <>
  // this room is a bucket
  RHOUSEBIT
  <>
  // This room is part of the house);

// exit

newtype(EXIT
  VECTOR
  '<primtype(VECTOR);
      [REST
        ATOM
        or(ROOM
          CEXIT
          NEXIT);]>);

// conditional exit

newstruc(CEXIT
  VECTOR
  CXFLAG
  ATOM
  // condition flag
  CXROOM
  ROOM
  // room it protects
  CXSTR
  or(FALSE
    STRING);
  // description
  CXACTION
  RAPPLIC
  // exit function);

newtype(NEXIT
  STRING);

// unusable exit description

\

// PARSER related types

// ACTION -- top level type for verbs

newstruc(ACTION
  VECTOR
  VNAME
  ATOM
  // atom associated with this action
  VDECL
  VSPEC
  // syntaxes for this verb (any number)
  VSTR
  STRING
  // string to print when talking about this verb);

// VSPEC -- uvector of syntaxes for a verb

newtype(VSPEC
  UVECTOR
  '<primtype(UVECTOR);
      [REST
        SYNTAX]>);

// SYNTAX -- a legal syntax for a sentence involving this verb

newstruc(SYNTAX
  VECTOR
  SYN1
  VARG
  // direct object, more or less
  SYN2
  VARG
  // indirect object, more or less
  SFCN
  VERB
  // function to handle this action
  SFLIP
  or(ATOM
    FALSE);
  // (?)
  SDRIVER
  or(ATOM
    FALSE);
  // (?));

// VARG -- types and locations of objects acceptable as args to verbs,    these go in the SYN1 and SYN2 slots of a SYNTAX.

newstruc(VARG
  VECTOR
  VBIT
  FIX
  // acceptable object characteristics
  VPREP
  or(PREP
    FALSE);
  // preposition that must precede(?) object
  VWORD
  FIX
  // locations object may be looked for in);

// flagbit definitions for VWORD of a VARG

flagword(VABIT
  <>
  // look in AOBJS
  VRBIT
  <>
  // look in ROBJS
  VTBIT
  <>
  // no-take
  VXBIT
  <>
  // (?) turned on by '=' in VARG spec);

// VTRNN -- test a bit in the VWORD slot of a VARG

defmac(VTRNN
  ('V
    'BIT)
  form(N==?
    form(CHTYPE
      form(ANDB
        .BIT
        form(VWORD
          .V););
      FIX);
    0););

// VERB -- name and function to apply to handle verb

newstruc(VERB
  VECTOR
  VNAME
  ATOM
  VFCN
  RAPPLIC);

// ORPHANS -- mysterious vector of orphan data

gdecl((ORPHANS)
  vector(or(FALSE
      ATOM);
    or(FALSE
      VERB);
    or(FALSE
      OBJECT);
    or(FALSE
      PREP);
    or(FALSE
      ATOM);););

and_q(msetg(OFLAG
    1);
  msetg(OVERB
    2);
  msetg(OSLOT1
    3);
  msetg(OPREP
    4);
  msetg(ONAME
    5););

// prepositional phrases

newstruc(PHRASE
  VECTOR
  PPREP
  PREP
  POBJ
  OBJECT);

\

// adventurer

newstruc(ADV
  VECTOR
  AROOM
  ROOM
  // where he is
  AOBJS
  list([REST
      OBJECT]);
  // what he's carrying
  ASCORE
  FIX
  // score
  AVEHICLE
  or(FALSE
    OBJECT);
  // what he's riding in
  AOBJ
  OBJECT
  // what he is
  AACTION
  RAPPLIC
  // special action for robot, etc.
  ASTRENGTH
  FIX
  // fighting strength
  ARAND
  ANY
  // ** reserved for future expansion **
  AFLAGS
  primtype(WORD);
  // flags THIS MUST BE SAME OFFSET AS OFLAGS!);

"bits in <AFLAGS adv>:    bit-name  bit-tester"

flagword(ASTAGGERED
  STAGGERED?
  // staggered?);

// object

newstruc(OBJECT
  VECTOR
  OID
  ATOM
  // unique name, SETG'd to this
  ONAMES
  uvector([REST
      ATOM]);
  // synonyms
  ODESC1
  STRING
  // description when not carried
  ODESC2
  STRING
  // short description
  ODESCO
  or(STRING
    FALSE);
  // description when untouched
  OACTION
  RAPPLIC
  // object-action
  OCONTENTS
  list([REST
      OBJECT]);
  // list of contents
  OCAN
  or(FALSE
    OBJECT);
  // what contains this
  OFLAGS
  primtype(WORD);
  // flags THIS MUST BE SAME OFFSET AS AFLAGS!
  OTOUCH?
  or(ATOM
    FALSE);
  // has this been touched?
  OLIGHT?
  FIX
  // light producer?
  OFVAL
  FIX
  // value for finding
  OTVAL
  FIX
  // value for putting in trophy case
  ORAND
  ANY
  // random slot
  OOPEN?
  or(ATOM
    FALSE);
  // is this open?
  OSIZE
  FIX
  // how big is it?
  OCAPAC
  FIX
  // how much can it hold?
  OADJS
  uvector([REST
      ADJECTIVE]);
  // adjectives for this
  OROOM
  or(FALSE
    ROOM);
  // what room its in
  OREAD
  or(FALSE
    STRING);
  // reading material);

"bits in <OFLAGS object>:    bit-name  bit-tester"

flagword(OVISON
  OVIS?
  // visible?
  READBIT
  READABLE?
  // readable?
  TAKEBIT
  CAN-TAKE?
  // takeable?
  DOORBIT
  DOOR?
  // object is door
  TRANSBIT
  TRANSPARENT?
  // object is transparent
  FOODBIT
  EDIBLE?
  // object is food
  NDESCBIT
  <>
  // object not describable
  DRINKBIT
  DRINKABLE?
  // object is drinkable
  CONTBIT
  <>
  // object can be opened/closed
  LIGHTBIT
  <>
  // object can provide light
  VICBIT
  <>
  // object is victim
  BURNBIT
  BURNABLE?
  // object is flammable
  FLAMEBIT
  <>
  // object is on fire
  TOOLBIT
  <>
  // object is a tool
  TURNBIT
  <>
  // object can be turned
  VEHBIT
  <>
  // object is a vehicle
  FINDMEBIT
  <>
  // can be reached from a vehicle
  SLEEPBIT
  <>
  // object is asleep
  SEARCHBIT
  <>
  // allow multi-level access into this
  SACREDBIT
  <>
  // thief can't take this
  TIEBIT
  <>
  // object can be tied
  ECHO-ROOM-BIT
  <>
  // nothing can be taken in echo room
  ACTORBIT
  <>
  // object is an actor
  WEAPONBIT
  <>
  // object is a weapon
  FIGHTBIT
  FIGHTING?
  // object is in melee
  VILLAIN
  <>
  // object is a bad guy
  STAGGERED
  <>
  // object can't fight this turn
  TRYTAKEBIT
  <>
  // object wants to handle not being taken
  NO-CHECK-BIT
  <>
  // ignore checks (in put & drop):  for EVERY and VALUA);

"extra stuff for flagword for objects"

"complement of the visible bit"

msetg(OVISOFF
  *777777777776*);

"can i be opened?"

defmac(OPENABLE?
  ('OBJ)
  form(TRNN
    .OBJ
    form(+
      ,DOORBIT
      ,CONTBIT);););

"complement of the bit state"

defmac(DESCRIBABLE?
  ('OBJ)
  form(NOT
    form(TRNN
      .OBJ
      ,NDESCBIT);););

"if object is a light or aflame, then flaming"

defmac(FLAMING?
  ('OBJ)
  form(AND
    form(TRNN
      .OBJ
      ,FLAMEBIT);
    form(1?
      form(OLIGHT?
        .OBJ););););

"if object visible and open or transparent, can see inside it"

defmac(SEE-INSIDE?
  ('OBJ)
  form(AND
    form(OVIS?
      .OBJ);
    form(OR
      form(TRANSPARENT?
        .OBJ);
      form(OOPEN?
        .OBJ););););

\

// demons

newstruc(HACK
  VECTOR
  HACTION
  RAPPLIC
  HOBJS
  list([REST
      ANY]);
  "REST"
  HROOMS
  list([REST
      ROOM]);
  HROOM
  ROOM
  HOBJ
  OBJECT
  HFLAG
  ANY);

// Clock interrupts

newstruc(CEVENT
  VECTOR
  CTICK
  FIX
  CACTION
  or(APPLICABLE
    OFFSET);
  CFLAG
  or(ATOM
    FALSE);
  CID
  ATOM);

\

setg(LOAD-MAX
  100);

setg(SCORE-MAX
  0);

gdecl((RAW-SCORE
    LOAD-MAX
    SCORE-MAX)
  FIX
  (RANDOM-LIST
    ROOMS
    SACRED-PLACES)
  list([REST
      ROOM]);
  (STARS
    OBJECTS
    WEAPONS
    NASTIES)
  list([REST
      OBJECT]);
  (PRSVEC)
  vector(or(FALSE
      VERB);
    or(FALSE
      OBJECT
      DIRECTION);
    or(FALSE
      OBJECT););
  (WINNER
    PLAYER)
  ADV
  (HERE)
  ROOM
  (INCHAN
    OUTCHAN)
  CHANNEL
  (DEMONS)
  LIST
  (MOVES
    DEATHS)
  FIX
  (DUMMY
    YUKS)
  vector([REST
      STRING]);
  (SWORD-DEMON)
  HACK);

\

"UTILITY FUNCTIONS"

"TO OPEN DOORS"

defmac(COND-OPEN
  ('DIR
    'RM)
  form(PROG
    list(list(EL
        form(MEMQ
          .DIR
          form(REXITS
            .RM););););
    #DECL
      ((EL)
        <primtype(VECTOR);
          ATOM
          CEXIT>)
    form(SETG
      form(CXFLAG
        form(2
          form(LVAL
            EL);););
      T);););

defmac(COND-CLOSE
  ('DIR
    'RM)
  form(PROG
    list(list(EL
        form(MEMQ
          .DIR
          form(REXITS
            .RM););););
    #DECL
      ((EL)
        <primtype(VECTOR);
          ATOM
          CEXIT>)
    form(SETG
      form(CXFLAG
        form(2
          form(LVAL
            EL);););
      <>);););

"APPLY AN OBJECT FUNCTION"

defmac(APPLY-OBJECT
  ('OBJ)
  form(PROG
    ((FOO
        form(OACTION
          .OBJ);))
    form(COND
      (form(NOT
          form(LVAL
            FOO););
        <>)
      (form(TYPE?
          form(LVAL
            FOO);
          ATOM);
        form(APPLY
          form(GVAL
            form(LVAL
              FOO);););)
      (form(DISPATCH
          form(LVAL
            FOO););));););

"FLUSH AN OBJECT FROM A ROOM"

define(REMOVE-OBJECT
  (OBJ
    "AUX"
    OCAN
    OROOM)
  #DECL
    ((OBJ)
      OBJECT
      (OCAN)
      or(OBJECT
        FALSE);
      (OROOM)
      or(FALSE
        ROOM);)
  cond((set(OCAN
        ocan(.OBJ););
      put(.OCAN
        ,OCONTENTS
        splice_out(.OBJ
          ocontents(.OCAN);););)
    (set(OROOM
        oroom(.OBJ););
      put(.OROOM
        ,ROBJS
        splice_out(.OBJ
          robjs(.OROOM);););)
    (memq(.OBJ
        robjs(,HERE););
      put(,HERE
        ,ROBJS
        splice_out(.OBJ
          robjs(,HERE);););));
  put(.OBJ
    ,OROOM
    <>);
  put(.OBJ
    ,OCAN
    <>););

defmac(INSERT-OBJECT
  ('OBJ
    'ROOM)
  form(PUT
    .ROOM
    ,ROBJS
    (form(PUT
        .OBJ
        ,OROOM
        .ROOM);
      chtype(form(ROBJS
          .ROOM);
        SEGMENT);)););

defmac(TAKE-OBJECT
  ('OBJ
    "OPTIONAL"
    ('WINNER
      ',WINNER))
  form(PUT
    .WINNER
    ,AOBJS
    (form(PUT
        .OBJ
        ,OROOM
        <>);
      chtype(form(AOBJS
          .WINNER);
        SEGMENT);)););

defmac(DROP-OBJECT
  ('OBJ
    "OPTIONAL"
    ('WINNER
      ',WINNER))
  form(PUT
    .WINNER
    ,AOBJS
    form(SPLICE-OUT
      .OBJ
      form(AOBJS
        .WINNER););););

define(KILL-OBJ
  (OBJ
    WINNER)
  #DECL
    ((OBJ)
      OBJECT
      (WINNER)
      ADV)
  cond((memq(.OBJ
        aobjs(.WINNER););
      put(.WINNER
        ,AOBJS
        splice_out(.OBJ
          aobjs(.WINNER);););)
    (remove_object(.OBJ);)););

define(FLUSH-OBJ
  ("TUPLE"
    OBJS
    "AUX"
    (WINNER
      ,WINNER))
  #DECL
    ((OBJS)
      tuple([REST
          STRING]);
      (WINNER)
      ADV)
  mapf(<>
    function((X
        "AUX"
        (Y
          find_obj(.X);))
      #DECL
        ((Y)
          OBJECT)
      and(memq(.Y
          aobjs(.WINNER););
        drop_object(find_obj(.X);
          .WINNER);););
    .OBJS););

"ROB-ADV:  TAKE ALL OF THE VALUABLES A HACKER IS CARRYING"

define(ROB-ADV
  (WIN
    NEWLIST)
  #DECL
    ((WIN)
      ADV
      (NEWLIST)
      list([REST
          OBJECT]);)
  mapf(<>
    function((X)
      #DECL
        ((X)
          OBJECT)
      cond((and(g_q(otval(.X);
              0);
            not(trnn(.X
                ,SACREDBIT);););
          put(.WIN
            ,AOBJS
            splice_out(.X
              aobjs(.WIN);););
          set(NEWLIST
            (.X
              !.NEWLIST));)););
    aobjs(.WIN););
  .NEWLIST);

"ROB-ROOM:  TAKE VALUABLES FROM A ROOM, PROBABILISTICALLY"

define(ROB-ROOM
  (RM
    NEWLIST
    PROB)
  #DECL
    ((RM)
      ROOM
      (NEWLIST)
      list([REST
          OBJECT]);
      (PROB)
      FIX)
  mapf(<>
    function((X)
      #DECL
        ((X)
          OBJECT)
      cond((and(g_q(otval(.X);
              0);
            not(trnn(.X
                ,SACREDBIT););
            ovis_q(.X);
            prob(.PROB););
          remove_object(.X);
          put(.X
            ,OTOUCH?
            T);
          set(NEWLIST
            (.X
              !.NEWLIST));)
        (type_q(orand(.X);
            ADV);
          set(NEWLIST
            rob_adv(orand(.X);
              .NEWLIST););)););
    robjs(.RM););
  .NEWLIST);

define(VALUABLES?
  (ADV)
  #DECL
    ((ADV)
      ADV)
  mapf(<>
    function((X)
      #DECL
        ((X)
          OBJECT)
      cond((g_q(otval(.X);
            0);
          mapleave(T);)););
    aobjs(.ADV);););

define(ARMED?
  (ADV
    "AUX"
    (WEAPONS
      ,WEAPONS))
  #DECL
    ((ADV)
      ADV)
  mapf(<>
    function((X)
      #DECL
        ((X)
          OBJECT)
      cond((memq(.X
            .WEAPONS);
          mapleave(T);)););
    aobjs(.ADV);););

define(LIGHT-SOURCE
  (ME)
  #DECL
    ((ME)
      ADV)
  mapf(<>
    function((X)
      cond((not(0_q(olight_q(.X);););
          mapleave(.X);)););
    aobjs(.ME);););

define(GET-DEMON
  (ID
    "AUX"
    (OBJ
      find_obj(.ID);)
    (DEMS
      ,DEMONS))
  #DECL
    ((ID)
      STRING
      (OBJ)
      OBJECT
      (DEMS)
      list([REST
          HACK]);)
  mapf(<>
    function((X)
      #DECL
        ((X)
          HACK)
      cond((eq_q(hobj(.X);
            .OBJ);
          mapleave(.X);)););
    .DEMS););

defmac(PICK-ONE
  ('VEC)
  form(NTH
    .VEC
    form(+
      1
      form(MOD
        form(RANDOM);
        form(LENGTH
          .VEC);););););

defmac(CLOCK-DISABLE
  ('EV)
  form(PUT
    .EV
    ,CFLAG
    <>););

defmac(CLOCK-ENABLE
  ('EV)
  form(PUT
    .EV
    ,CFLAG
    T););

define(YES/NO
  (NO-IS-BAD?
    "AUX"
    (INBUF
      ,INBUF)
    (INCHAN
      ,INCHAN))
  #DECL
    ((INBUF)
      STRING
      (NO-IS-BAD?)
      or(ATOM
        FALSE);)
  reset(.INCHAN);
  readstring(.INBUF
    .INCHAN
    ,READER-STRING);
  cond((.NO-IS-BAD?
      not(memq(1(.INBUF);
          "NnfF"););)
    (T
      memq(1(.INBUF);
        "TtYy");)););

defmac(APPLY-RANDOM
  ('FROB
    "OPTIONAL"
    ('MUMBLE
      <>))
  form(COND
    (form(TYPE?
        .FROB
        ATOM);
      cond((.MUMBLE
          form(APPLY
            form(GVAL
              .FROB);
            .MUMBLE);)
        (form(APPLY
            form(GVAL
              .FROB););));)
    (T
      form(DISPATCH
        .FROB
        .MUMBLE);)););

define(DA
  (FN
    "OPTIONAL"
    (FOO
      <>))
  #DECL
    ((FN)
      or(APPLICABLE
        ATOM
        FIX);)
  prog(()
    cond((type_q(.FN
          FIX);
        dispatch(.FN
          .FOO);)
      (applicable_q(.FN);
        cond((.FOO
            apply(.FN
              .FOO);)
          (apply(.FN);));)
      (gassigned_q(.FN);
        set(FN
          ,.FN);
        again();)
      (error(UNASSIGNED-VARIABLE!-ERRORS
          .FN
          DA);));););

"OLD MAZER"

moblist(FLAG
  17);

psetg(NULL-DESC
  "");

psetg(NULL-EXIT
  chtype([]
    EXIT););

psetg(NULL-SYN
  !
  []);

define(FIND-ROOM
  (ID
    "AUX"
    ATM
    ROOM)
  #DECL
    ((ID)
      or(ATOM
        STRING);
      (VALUE)
      ROOM
      (ROOM)
      ROOM
      (ATM)
      or(ATOM
        FALSE);)
  cond((type_q(.ID
        ATOM);
      set(ID
        spname(.ID););));
  cond((and(set(ATM
          lookup(.ID
            ,ROOM-OBL););
        gassigned_q(.ATM););
      ,.ATM)
    (or(.ATM
        set(ATM
          insert(.ID
            ,ROOM-OBL);););
      setg(.ATM
        set(ROOM
          chtype(vector(.ATM
              ,NULL-DESC
              ,NULL-DESC
              <>
              <>
              ,NULL-EXIT
              ()
              <>
              0
              0
              0
              T);
            ROOM);););
      setg(ROOMS
        (.ROOM
          !,ROOMS));
      .ROOM)););

define(FIND-OBJ
  (ID
    "AUX"
    OBJ
    ATM)
  #DECL
    ((ID)
      or(ATOM
        STRING);
      (OBJ)
      OBJECT
      (ATM)
      or(ATOM
        FALSE);
      (VALUE)
      OBJECT)
  cond((type_q(.ID
        ATOM);
      set(ID
        spname(.ID););));
  cond((and(set(ATM
          lookup(.ID
            ,OBJECT-OBL););
        gassigned_q(.ATM););
      ,.ATM)
    (or(.ATM
        set(ATM
          insert(.ID
            ,OBJECT-OBL);););
      setg(.ATM
        set(OBJ
          chtype([.ATM
              ,NULL-SYN
              ,NULL-DESC
              ,NULL-DESC
              <>
              <>
              ()
              <>
              0
              <>
              0
              0
              0
              <>
              <>
              5
              0
              ,NULL-SYN
              <>
              <>]
            OBJECT);););
      setg(OBJECTS
        (.OBJ
          !,OBJECTS));
      .OBJ)););

define(FUNCTION-PRINT
  (FROB)
  #DECL
    ((FROB)
      or(ATOM
        OFFSET
        APPLICABLE
        FALSE);)
  cond((not(.FROB);
      princ("<>");)
    (type_q(.FROB
        RSUBR
        RSUBR-ENTRY);
      prin1(2(.FROB););)
    (type_q(.FROB
        ATOM);
      prin1(.FROB);)
    (type_q(.FROB
        OFFSET);
      princ("#OFFSET ");
      prin1(get_atom(.FROB););)
    (princ("#FUNCTION ");
      prin1(get_atom(.FROB););)););
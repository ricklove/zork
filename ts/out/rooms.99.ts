// GUTS OF FROB:  BASIC VERBS, COMMAND READER, PARSER, VOCABULARY HACKERS.

setg(
  alt_flag,
  t)

gdecl(
  (muddle),
  fix,
  (tenex_Q),
  or(
    atom,
    false),
  (vers
    dev
    snm
    scratch_str),
  string)

define(
  save_it,
  ("OPTIONAL"
    (fn
      cond(
        (l_Q(
            ,muddle,
            100)
          "MADMAN;MADADV SAVE"),
        (t
          "<MDL>MADADV.SAVE")))
    "AUX"
    (muddle
      ,muddle)
    stv
    (st
      remarkably_disgusting_code(
        ))),
  #decl
    ((fn)
      string
      (muddle)
      fix
      (stv)
      or(
        string,
        fix)),
  put(
    find_obj(
      "PAPER"),
    ,odesc1,
    unspeakable_code(
      )),
  setg(
    vers,
    _st),
  setg(
    script_channel,
    <>),
  setg(
    raw_score,
    0),
  set(
    ih,
    on(
      "IPC",
      ,ilo,
      1)),
  handler(
    ,divert_int,
    ,divert_hand),
  cond(
    (g_Q(
        _muddle,
        100)
      setg(
        scratch_str,
        istring(
          32))
      setg(
        dev,
        "DSK")
      setg(
        snm,
        "MDL")),
    (sname(
        "")
      setg(
        dev,
        "DSK")
      setg(
        snm,
        "MADMAN"))),
  int_level(
    100000),
  cond(
    (__Q(
        save(
          _fn),
        "SAVED")
      int_level(
        0)
      t),
    (t
      // STARTER on 10x sets up tty correctly, setg's DEV to \"MDL\"     if that device exists; if not, (sort of) returns directory muddle     came from.  On its it returns # zorkers currently in existence.
      cond(
        (and(
            type_Q(
              set(
                stv,
                starter(
                  )),
              fix),
            g_Q(
              _stv,
              3))
          or(
            member(
              setg(
                xunm,
                xuname(
                  )),
              ,winners),
            __Q(
              ,xunm,
              "SEC"),
            __Q(
              ,xunm,
              "ELBOW"),
            and(
              off(
                "CHAR",
                ,inchan),
              tell(
                "There appears before you a threatening figure clad all over\nin heavy black armor.  His legs seem like the massive trunk\nof the oak tree.  His broad shoulders and helmeted head loom\nhigh over your own puny frame and you realize that his powerful\narms could easily crush the very life from your body.  There\nhangs from his belt a veritable arsenal of deadly weapons:\nsword, mace, ball and chain, dagger, lance, and trident.\nHe speaks with a commanding voice:\n\n		\"YOU SHALL NOT PASS \"\n\nAs he grabs you by the neck all grows dim about you."),
              quit(
                )))),
        (type_Q(
            _stv,
            string)
          setg(
            snm,
            substruc(
              ,scratch_str,
              0,
              _(
                length(
                  ,scratch_str),
                length(
                  memq(
                    _X__,
                    _stv)))))))
      cond(
        (g_Q(
            ,muddle,
            100)
          setg(
            tenex_Q,
            getsys(
              ))),
        (apply(
            ,ipc_off)
          apply(
            ,ipc_on,
            uname(
              ),
            "ZORK")))
      set(
        bh,
        on(
          "BLOCKED",
          ,blo,
          100))
      start(
        "WHOUS",
        _st))))

"Stuff for diverting gc's"

setg(
  divert_cnt,
  0)

setg(
  divert_max,
  99)

setg(
  divert_inc,
  4000)

setg(
  divert_amt,
  0)

setg(
  divert_lmt,
  100000)

gdecl(
  (divert_cnt
    divert_max
    divert_inc
    divert_amt
    divert_lmt),
  fix)

define(
  divert_fcn,
  (amt
    reason),
  setg(
    divert_cnt,
    _(
      ,divert_cnt,
      1)),
  setg(
    divert_amt,
    _(
      ,divert_amt,
      ,divert_inc,
      _amt)),
  cond(
    (or(
        g_Q(
          ,divert_cnt,
          ,divert_max),
        g_Q(
          ,divert_amt,
          ,divert_lmt))
      // Too much diversion ?
      setg(
        divert_amt,
        setg(
          divert_cnt,
          0))
      gc_fcn(
        )
      gc(
        )),
    (else
      // Divert this request for storage
      cond(
        (1_Q(
            ,divert_cnt)
          // First diversion ?
          handler(
            ,gc_int,
            ,gc_hand)))
      bloat(
        _(
          _amt,
          ,divert_inc))
      // Get storage desired plus extra increment)))

setg(
  divert_hand,
  handler(
    setg(
      divert_int,
      event(
        "DIVERT-AGC",
        1000)),
    ,divert_fcn))

off(
  ,divert_hand)

define(
  gc_fcn,
  ("TUPLE"
    t),
  off(
    ,gc_hand),
  setg(
    divert_amt,
    setg(
      divert_cnt,
      0)))

setg(
  gc_hand,
  handler(
    setg(
      gc_int,
      event(
        "GC",
        11)),
    ,gc_fcn))

off(
  ,gc_hand)

define(
  xuname,
  (),
  #decl
    ((value)
      string),
  mapf(
    ,string,
    function(
      (x),
      #decl
        ((x)
          character),
      cond(
        (or(
            0_Q(
              ascii(
                _x)),
            _EQ_Q(
              ascii(
                _x),
              32))
          mapstop(
            )),
        (t
          _x))),
    gxuname(
      )))

define(
  its_get_name,
  (uname
    "AUX"
    (nm
      field(
        _uname,
        ,_name))
    cma
    jr
    lfst
    llst
    tlen
    tstr
    str),
  #decl
    ((str
        tstr
        uname)
      string
      (nm
        cma
        jr)
      or(
        string,
        false)
      (tlen
        llst
        lfst)
      fix),
  cond(
    (_nm
      cond(
        (set(
            cma,
            memq(
              _X__,
              _nm))
          set(
            llst,
            _(
              length(
                _nm),
              length(
                _cma)))
          set(
            cma,
            rest(
              _cma))
          set(
            lfst,
            length(
              _cma))
          cond(
            (set(
                jr,
                memq(
                  _X__,
                  _cma))
              set(
                lfst,
                _(
                  _lfst,
                  length(
                    _jr)))))
          repeat(
            (),
            cond(
              (empty_Q(
                  _cma)
                return(
                  )),
              (memq(
                  1(
                    _cma),
                  %string(
                      ascii(
                        32),
                      ascii(
                        9)))
                set(
                  cma,
                  rest(
                    _cma))
                set(
                  lfst,
                  _(
                    _lfst,
                    1))),
              (else
                return(
                  ))))
          set(
            tlen,
            _(
              _lfst,
              1,
              _llst,
              length(
                _jr)))
          set(
            str,
            istring(
              _tlen,
              _X__))
          set(
            tstr,
            _str)
          substruc(
            _cma,
            0,
            _lfst,
            _tstr)
          set(
            tstr,
            rest(
              _tstr,
              _(
                _lfst,
                1)))
          substruc(
            _nm,
            0,
            _llst,
            _tstr)
          and(
            _jr,
            substruc(
              _jr,
              0,
              length(
                _jr),
              rest(
                _tstr,
                _llst)))
          setg(
            user_name,
            _str)),
        (else
          setg(
            user_name,
            _nm))))))

define(
  unspeakable_code,
  ("AUX"
    str
    nstr
    (len_i
      0)
    (o
      find_obj(
        "PAPER"))),
  #decl
    ((o)
      object
      (nstr
        str)
      string
      (len_i)
      fix),
  set(
    str,
    memq(
      _X__,
      oread(
        _o))),
  cond(
    (_EQ_Q(
        1(
          back(
            _str,
            2)),
        _X_1)
      set(
        str,
        back(
          _str,
          2))
      set(
        len_i,
        1)),
    (set(
        str,
        back(
          _str,
          1)))),
  set(
    nstr,
    rest(
      memq(
        _X__,
        rest(
          memq(
            _X__,
            _str))),
      3)),
  string(
    "There is an issue of US NEWS & DUNGEON REPORT dated",
    substruc(
      _str,
      0,
      _(
        length(
          _str),
        length(
          _nstr))),
    "here."))

define(
  remarkably_disgusting_code,
  ("AUX"
    (n
      dskdate(
        ))),
  #decl
    ((n)
      primtype(
        word)),
  string(
    "This version created",
    nth(
      ,months,
      chtype(
        getbits(
          _n,
          bits(
            4,
            23)),
        fix)),
    _X__,
    unparse(
      chtype(
        getbits(
          _n,
          bits(
            5,
            18)),
        fix)),
    _X__))

define(
  version,
  (),
  tell(
    ,vers))

setg(
  played_time,
  0)

gdecl(
  (played_time),
  fix)

define(
  get_time,
  ("AUX"
    (now
      dskdate(
        ))
    (then
      ,intime)),
  #decl
    ((now
        then)
      primtype(
        word)),
  _(
    cond(
      (n_EQ_Q(
          chtype(
            getbits(
              _now,
              bits(
                18,
                18)),
            fix),
          chtype(
            getbits(
              _then,
              bits(
                18,
                18)),
            fix))
        _(
          _(
            _(
              chtype(
                getbits(
                  _now,
                  bits(
                    18,
                    0)),
                fix),
              _(
                24,
                7200)),
            chtype(
              getbits(
                _then,
                bits(
                  18,
                  0)),
              fix)),
          2)),
      (_(
          _(
            chtype(
              getbits(
                _now,
                bits(
                  18,
                  0)),
              fix),
            chtype(
              getbits(
                _then,
                bits(
                  18,
                  0)),
              fix)),
          2))),
    ,played_time))

define(
  play_time,
  ("OPTIONAL"
    (outchan
      ,outchan)
    (loser_Q
      t)
    "AUX"
    time
    mins),
  #decl
    ((mins
        time)
      fix
      (outchan)
      special(
        channel)
      (loser_Q)
      or(
        atom,
        false)),
  set(
    time,
    get_time(
      )),
  setg(
    tell_flag,
    t),
  cond(
    (_loser_Q
      princ(
        "You have been playing DUNGEON for")),
    (t
      princ(
        "Played for"))),
  and(
    g_Q(
      set(
        mins,
        _(
          _time,
          3600)),
      0),
    prin1(
      _mins),
    princ(
      "hour"),
    or(
      1_Q(
        _mins),
      princ(
        "s")),
    princ(
      ",")),
  cond(
    (g_Q(
        set(
          mins,
          mod(
            _(
              _time,
              60),
            60)),
        0)
      prin1(
        _mins)
      princ(
        "minute")
      cond(
        (not(
            1_Q(
              _mins))
          princ(
            "s")))
      princ(
        ", and"))),
  prin1(
    set(
      mins,
      mod(
        _time,
        60))),
  princ(
    "second"),
  or(
    1_Q(
      _mins),
    princ(
      "s")),
  cond(
    (_loser_Q
      princ(
        ".")),
    (princ(
        "."))),
  _time)

define(
  pc,
  (),
  t)

define(
  handle,
  (frm
    "TUPLE"
    zork
    "AUX"
    zf),
  #decl
    ((zf)
      any),
  put(
    ,outchan,
    13,
    80),
  put(
    1(
      back(
        ,inchan)),
    6,
    #lose
      27),
  cond(
    (and(
        or(
          not(
            gassigned_Q(
              xunm)),
          member(
            ,xunm,
            ,winners)),
        pc(
          ))
      and(
        gassigned_Q(
          saverep),
        setg(
          rep,
          ,saverep))
      and(
        assigned_Q(
          bh),
        off(
          _bh))
      int_level(
        0)
      setg(
        dbg,
        t)
      setg(
        alt_flag,
        t)),
    (t
      cond(
        (and(
            not(
              empty_Q(
                _zork)),
            _EQ_Q(
              1(
                _zork),
              control_g_Q_X_errors))
          int_level(
            0)
          finish(
            )
          put(
            1(
              back(
                ,inchan)),
            6,
            cond(
              (g_Q(
                  ,muddle,
                  100)
                cond(
                  (,tenex_Q
                    #lose
                      _37_),
                  (t
                    #lose
                      _000000000012_))),
              (t
                #lose
                  _000000000015_)))
          erret(
            t,
            _frm)),
        (and(
            _EQ_Q(
              length(
                _zork),
              3),
            _EQ_Q(
              1(
                _zork),
              file_system_error_X_errors),
            not(
              set(
                zf,
                3(
                  _zork))),
            _EQ_Q(
              length(
                _zf),
              3),
            __Q(
              1(
                _zf),
              "ILLEGAL CHR AFTER CNTRL P ON TTY DISPLAY"))
          // HACK FOR ILLEGAL CHR AFTER CTRL-P
          put(
            1(
              back(
                ,inchan)),
            6,
            #lose
              _000000000015_)
          int_level(
            0)
          erret(
            t,
            _frm)),
        (tell(
            "I'm sorry, you seem to have encountered an error in the program.\nSend mail to DUNGEON@MIT-DMS describing what it was you tried to do.")
          tell(
            ,vers)
          mapf(
            <>,
            \* FUNCTION *\
              (x) => (
              print,
              _x),
            _zork)
          finish(
            #false
              (". Error.")))))))

psetg(
  winners,
  () => ["BKD"
      "TAA"
      "MARC"
      "PDL"
      "MDL"])

gdecl(
  (winners),
  vector(
    [rest
      string]))

or(
  lookup(
    "COMPILE",
    root(
      )),
  lookup(
    "GLUE",
    get(
      package,
      oblist)),
  setg(
    errh,
    handler(
      or(
        get(
          error_X_interrupts,
          interrupt),
        event(
          "ERROR",
          8)),
      ,handle)))

gdecl(
  (moves),
  fix,
  (script_channel),
  or(
    channel,
    false))

define(
  start,
  (rm
    "OPTIONAL"
    (st
      "")
    "AUX"
    fn
    (muddle
      ,muddle)
    (xunm
      xuname(
        ))),
  #decl
    ((st
        rm)
      string
      (muddle)
      fix
      (xunm)
      string
      (fn)
      or(
        false,
        string)),
  setg(
    xunm,
    _xunm),
  setg(
    ptemp,
    chtype(
      [chtype(
          with_X_words,
          prep)
        find_obj(
          "!!!!!")],
      phrase)),
  setg(
    intime,
    dskdate(
      )),
  cond(
    (l_Q(
        _muddle,
        100)
      and(
        g_Q(
          length(
            _xunm),
          2),
        __Q(
          substruc(
            _xunm,
            0,
            3),
          "___"),
        quit(
          ))
      set(
        fn,
        its_get_name(
          _xunm))),
    (set(
        fn,
        get_name(
          )))),
  cond(
    (_fn
      setg(
        user_name,
        _fn)),
    (setg(
        user_name,
        _xunm))),
  setg(
    deaths,
    0),
  setg(
    moves,
    0),
  setg(
    winner,
    ,player),
  put(
    ,winner,
    ,aroom,
    setg(
      here,
      find_room(
        _rm))),
  tell(
    "Welcome to Dungeon.",
    1,
    _st),
  random(
    chtype(
      dskdate(
        ),
      fix)),
  int_level(
    0),
  contin(
    ))

define(
  contin,
  (),
  setg(
    alt_flag,
    <>),
  put(
    1(
      back(
        ,inchan)),
    6,
    cond(
      (g_Q(
          ,muddle,
          100)
        cond(
          (,tenex_Q
            #lose
              _37_),
          (t
            #lose
              _000000000012_))),
      (t
        #lose
          _000000000015_))),
  setg(
    saverep,
    ,rep),
  setg(
    rep,
    ,rdcom),
  reset(
    ,inchan),
  setg(
    winner,
    ,player),
  put(
    ,prsvec,
    2,
    <>),
  ,null)

setg(
  my_script,
  <>)

gdecl(
  (my_script),
  or(
    atom,
    false))

define(
  make_script,
  ("AUX"
    ch),
  #decl
    ((ch)
      or(
        channel,
        false)),
  cond(
    (,script_channel
      <>),
    (set(
        ch,
        open(
          "PRINT",
          string(
            "MARC;%Z",
            ,xunm,
            ">")))
      put(
        top(
          ,inchan),
        1,
        (_ch))
      put(
        top(
          ,outchan),
        1,
        (_ch))
      setg(
        script_channel,
        _ch)
      setg(
        my_script,
        t))))

define(
  flush_me,
  (),
  unwind(
    prog(
      (),
      tell(
        "Suddenly, a sinister, wraithlike figure appears before you, seeming\nto float in the air.  He glows with an eldritch light.  In a barely\naudible voice he says, \"Begone, defiler!  Your presence upsets the\nvery balance of the System itself!\"  With a sinister chuckle, he\nraises his oaken staff, taps you on the head, and fades into the\ngloom.  In his place appears a tastefully lettered sign reading:\n\n			DUNGEON CLOSED\n\nAt that instant, you disappear, and all your belongings clatter to\nthe ground."),
      finish(
        <>)),
    finish(
      <>)))

define(
  do_script,
  ("AUX"
    ch
    (unm
      ,xunm)
    (muddle
      ,muddle)),
  #decl
    ((ch)
      or(
        channel,
        false)
      (unm)
      string
      (muddle)
      fix),
  cond(
    (,my_script
      do_unscript(
        <>))),
  cond(
    (,script_channel
      tell(
        "You are already scripting.")),
    (and(
        or(
          g_Q(
            _muddle,
            100),
          and(
            not(
              member(
                "GUEST",
                _unm)),
            set(
              ch,
              open(
                "READ",
                ".FILE.",
                "(DIR)",
                "DSK",
                _unm)),
            close(
              _ch),
            set(
              ch,
              open(
                "READ",
                "_MSGS_",
                _unm,
                "DSK",
                _unm)),
            close(
              _ch))),
        set(
          ch,
          open(
            "PRINT",
            "ZORK",
            "SCRIPT",
            "DSK",
            _unm)))
      put(
        top(
          ,inchan),
        1,
        (_ch))
      put(
        top(
          ,outchan),
        1,
        (_ch))
      setg(
        script_channel,
        _ch)
      cond(
        (l_Q(
            ,muddle,
            100)
          tell(
            "Scripting to",
            1,
            ,xunm,
            ";ZORK SCRIPT")),
        (t
          tell(
            "Scripting to <",
            1,
            ,xunm,
            ">ZORK.SCRIPT")))),
    (t
      tell(
        "I can't open the script channel."))))

define(
  do_unscript,
  ("OPTIONAL"
    (verbose
      t)),
  #decl
    ((verbose)
      or(
        atom,
        false)),
  cond(
    (,script_channel
      put(
        top(
          ,inchan),
        1,
        ())
      put(
        top(
          ,outchan),
        1,
        ())
      close(
        ,script_channel)
      setg(
        script_channel,
        <>)
      and(
        _verbose,
        tell(
          "Scripting off."))),
    (and(
        _verbose,
        tell(
          "Scripting wasn't on.")))))

gdecl(
  (then),
  fix)

define(
  do_save,
  ("AUX"
    (muddle
      ,muddle)
    ch
    (unm
      ,xunm)),
  #decl
    ((ch)
      or(
        channel,
        false)
      (muddle)
      fix
      (unm)
      string),
  cond(
    (or(
        g_Q(
          _muddle,
          100),
        and(
          not(
            member(
              "GUEST",
              _unm)),
          set(
            ch,
            open(
              "READ",
              ".FILE.",
              "(DIR)",
              "DSK",
              _unm)),
          close(
            _ch)))
      cond(
        (or(
            g_Q(
              _muddle,
              100),
            and(
              set(
                ch,
                open(
                  "READ",
                  "_MSGS_",
                  _unm,
                  "DSK",
                  _unm)),
              close(
                _ch)))
          and(
            ,script_channel,
            do_unscript(
              ))
          tell(
            "Saving.")
          int_level(
            100000)
          off(
            "CHAR",
            ,inchan)
          setg(
            then,
            chtype(
              dskdate(
                ),
              fix))
          setg(
            played_time,
            get_time(
              ))
          cond(
            (set(
                ch,
                open(
                  "PRINTB",
                  cond(
                    (l_Q(
                        _muddle,
                        100)
                      string(
                        "DSK:",
                        _unm,
                        ";ZORK SAVE")),
                    (t
                      string(
                        "DSK:<",
                        _unm,
                        ">ZORK.SAVE")))))
              save_game(
                _ch)
              finish(
                chtype(
                  () => (". Saved."),
                  false))),
            (tell(
                "Save failed.")
              tell(
                1(
                  _ch),
                1,
                "",
                2(
                  _ch))))),
        (tell(
            "Can't open channel for save.")))),
    (t
      tell(
        "Can't open channel for save."))))

define(
  do_restore,
  ("AUX"
    ch
    str
    (muddle
      ,muddle)
    nowd
    now
    thend),
  #decl
    ((ch)
      or(
        channel,
        false)
      (str)
      string
      (nowd
        now
        thend
        muddle)
      fix),
  cond(
    (l_Q(
        _muddle,
        100)
      set(
        str,
        string(
          "DSK:",
          ,xunm,
          ";ZORK SAVE"))),
    (t
      set(
        str,
        string(
          "DSK:<",
          ,xunm,
          ">ZORK.SAVE")))),
  prog(
    ((foo
        t)
      (snm
        sname(
          ))),
    #decl
      ((foo)
        or(
          atom,
          false)
        (snm)
        special(
          string)),
    cond(
      (set(
          ch,
          open(
            "READB",
            _str))
        cond(
          (restore_game(
              _ch)
            cond(
              (member(
                  ,xunm,
                  ,winners)),
              (_EQ_Q(
                  set(
                    nowd,
                    chtype(
                      getbits(
                        set(
                          now,
                          chtype(
                            dskdate(
                              ),
                            fix)),
                        bits(
                          18,
                          18)),
                      fix)),
                  set(
                    thend,
                    chtype(
                      getbits(
                        ,then,
                        bits(
                          18,
                          18)),
                      fix)))
                cond(
                  (g__Q(
                      _(
                        _now,
                        ,then),
                      2400)),
                  (tell(
                      "It's too soon.")
                    cond(
                      (g_Q(
                          ,muddle,
                          100)
                        off(
                          "CHAR",
                          ,inchan)
                        int_level(
                          10000)
                        quit(
                          )))
                    quit(
                      )))),
              (1_Q(
                  _(
                    _nowd,
                    _thend))
                cond(
                  (g__Q(
                      _(
                        _(
                          chtype(
                            getbits(
                              _now,
                              bits(
                                18,
                                0)),
                            fix),
                          _(
                            24,
                            7200)),
                        chtype(
                          getbits(
                            _now,
                            bits(
                              18,
                              0)),
                          fix)),
                      2400)),
                  (tell(
                      "It's too soon.")
                    quit(
                      )))))
            setg(
              intime,
              _now)
            tell(
              "Restored.")),
          (tell(
              "Restore failed.")))
        room_desc(
          )),
      (and(
          _foo,
          g_Q(
            _muddle,
            100))
        set(
          str,
          string(
            sname(
              ),
            "ZORK.SAVE"))
        set(
          foo,
          <>)
        again(
          )),
      (tell(
          2(
            _ch),
          1,
          "",
          1(
            _ch))))))

define(
  prob,
  (num),
  #decl
    ((num)
      fix),
  l__Q(
    mod(
      random(
        ),
      100),
    _num))

"GET-ATOM TAKES A VALUE AND SEARCHES INITIAL FOR FIRST ATOM\nSETG'ED TO THAT."

define(
  get_atom,
  act,
  (val
    "AUX"
    (o
      get(
        initial,
        oblist))),
  #decl
    ((o)
      oblist),
  mapf(
    <>,
    function(
      (x),
      #decl
        ((x)
          list(
            [rest
              atom])),
      mapf(
        <>,
        function(
          (x),
          #decl
            ((x)
              atom),
          cond(
            (and(
                gassigned_Q(
                  _x),
                _EQ_Q(
                  ,_x,
                  _val))
              return(
                _x,
                _act)))),
        _x)),
    _o))

// ROOM-INFO --  PRINT SOMETHING ABOUT THIS PLACE  1. CHECK FOR LIGHT --> ELSE WARN LOSER  2. GIVE A DESCRIPTION OF THE ROOM  3. TELL WHAT'S ON THE FLOOR IN THE WAY OF OBJECTS  4. SIGNAL ENTRY INTO THE ROOM

setg(
  brief_X_flag,
  <>)

setg(
  super_brief_X_flag,
  <>)

gdecl(
  (super_brief_X_flag
    brief_X_flag),
  or(
    atom,
    false))

define(
  brief,
  (),
  setg(
    brief_X_flag,
    t),
  tell(
    "Brief descriptions."))

define(
  super_brief,
  (),
  setg(
    super_brief_X_flag,
    t),
  tell(
    "No long descriptions."))

define(
  un_brief,
  (),
  setg(
    brief_X_flag,
    <>),
  setg(
    super_brief_X_flag,
    <>),
  tell(
    "Long descriptions."))

define(
  un_super_brief,
  (),
  setg(
    super_brief_X_flag,
    <>),
  tell(
    "Some long descriptions."))

define(
  room_desc,
  (),
  room_info(
    t))

define(
  room_info,
  ("OPTIONAL"
    (full
      <>)
    "AUX"
    (av
      avehicle(
        ,winner))
    (rm
      ,here)
    (prso
      2(
        ,prsvec))
    (winobj
      find_obj(
        "#####"))
    (outchan
      ,outchan)
    ra),
  #decl
    ((rm)
      room
      (winobj)
      object
      (av)
      or(
        false,
        object)
      (outchan)
      channel
      (prso)
      or(
        direction,
        false,
        object)
      (full)
      or(
        atom,
        false)),
  setg(
    tell_flag,
    t),
  and(
    type_Q(
      _prso,
      direction),
    put(
      ,prsvec,
      2,
      <>)),
  prog(
    (),
    cond(
      (n_EQ_Q(
          ,here,
          aroom(
            ,player))
        put(
          ,prsvec,
          1,
          ,walk_in_X_words)
        tell(
          "Done.")
        return(
          )),
      (and(
          _prso,
          type_Q(
            _prso,
            object))
        cond(
          (object_action(
              )),
          (oread(
              _prso)
            tell(
              oread(
                _prso))),
          (tell(
              "I see nothing special about the",
              1,
              odesc2(
                _prso),
              ".")))
        return(
          )),
      (not(
          lit_Q(
            _rm))
        tell(
          "It is pitch black.  You are likely to be eaten by a grue.")
        return(
          <>)),
      (or(
          and(
            not(
              _full),
            ,super_brief_X_flag),
          and(
            rseen_Q(
              _rm),
            or(
              ,brief_X_flag,
              prob(
                80)),
            not(
              _full)))
        tell(
          rdesc2(
            _rm))),
      (and(
          empty_Q(
            rdesc1(
              _rm)),
          set(
            ra,
            raction(
              _rm)))
        put(
          ,prsvec,
          1,
          ,look_X_words)
        apply_random(
          _ra)
        put(
          ,prsvec,
          1,
          ,foo_X_words)
        // Something innocuous),
      (tell(
          rdesc1(
            _rm)))),
    put(
      _rm,
      ,rseen_Q,
      t),
    and(
      _av,
      tell(
        "You are in the",
        1,
        odesc2(
          _av),
        ".")),
    mapf(
      <>,
      function(
        (x),
        #decl
          ((x)
            object),
        cond(
          (and(
              ovis_Q(
                _x),
              describable_Q(
                _x))
            cond(
              (_EQ_Q(
                  _x,
                  _av)),
              (t
                cond(
                  (long_desc_obj(
                      _x)
                    and(
                      _av,
                      tell(
                        "[in the room]",
                        0))
                    crlf(
                      )))))
            cond(
              (trnn(
                  _x,
                  ,actorbit)
                invent(
                  orand(
                    _x))),
              (see_inside_Q(
                  _x)
                print_cont(
                  _x,
                  _av,
                  _winobj,
                  ,indentstr,
                  cond(
                    (_full),
                    (,super_brief_X_flag
                      <>),
                    (,brief_X_flag
                      <>),
                    (t)))))))),
      robjs(
        _rm)),
    cond(
      (and(
          set(
            ra,
            raction(
              _rm)),
          not(
            _full))
        put(
          ,prsvec,
          1,
          ,walk_in_X_words)
        apply_random(
          _ra)
        put(
          ,prsvec,
          1,
          ,foo_X_words))),
    t))

psetg(
  indentstr,
  rest(
    istring(
      8),
    8))

define(
  print_cont,
  print_c,
  (obj
    av
    winobj
    indent
    "OPTIONAL"
    (case_Q
      t)
    "AUX"
    (cont
      ocontents(
        _obj))),
  #decl
    ((av)
      or(
        false,
        object)
      (obj
        winobj)
      object
      (indent)
      string
      (cont)
      list(
        [rest
          object])
      (case_Q)
      or(
        atom,
        false)),
  cond(
    (not(
        empty_Q(
          _cont))
      cond(
        (_EQ_Q(
            _obj,
            find_obj(
              "TCASE"))
          cond(
            (not(
                _case_Q)
              return(
                t,
                _print_c)))
          tell(
            "Your collection of treasures consists of:")),
        (not(
            and(
              _EQ_Q(
                length(
                  _cont),
                1),
              _EQ_Q(
                1(
                  _cont),
                find_obj(
                  "#####"))))
          tell(
            _indent,
            0)
          tell(
            "The",
            1,
            odesc2(
              _obj),
            "contains:")),
        (return(
            t,
            _print_c)))
      mapf(
        <>,
        function(
          (y),
          #decl
            ((y)
              object),
          cond(
            (and(
                _av,
                _EQ_Q(
                  _y,
                  _winobj))),
            (and(
                ovis_Q(
                  _y),
                describable_Q(
                  _y),
                not(
                  empty_Q(
                    odesc2(
                      _y))))
              tell(
                _indent,
                1,
                "A",
                odesc2(
                  _y)))),
          cond(
            (see_inside_Q(
                _y)
              print_cont(
                _y,
                _av,
                _winobj,
                back(
                  _indent))))),
        ocontents(
          _obj)))))

"GIVE LONG DESCRIPTION OF OBJECT"

define(
  long_desc_obj,
  (obj
    "AUX"
    str),
  #decl
    ((obj)
      object),
  cond(
    (or(
        otouch_Q(
          _obj),
        not(
          odesco(
            _obj)))
      set(
        str,
        odesc1(
          _obj))),
    (set(
        str,
        odesco(
          _obj)))),
  cond(
    (empty_Q(
        _str)
      <>),
    (tell(
        _str,
        0))))

"TRUE IF PARSER WON:  OTHERWISE INHIBITS OBJECT ACTIONS, CLOCKS (BUT NOT THIEF)."

gdecl(
  (parse_won),
  or(
    atom,
    false))

psetg(
  reader_string,
  string(
    ascii(
      27),
    ascii(
      13),
    ascii(
      10)))

define(
  rdcom,
  ("OPTIONAL"
    (ivec
      <>)
    "AUX"
    (str
      ,reader_string)
    vc
    rvec
    rm
    (inplen
      1)
    (inbuf
      ,inbuf)
    (winner
      ,winner)
    av
    (outchan
      ,outchan)
    random_action),
  #decl
    ((rvec)
      or(
        false,
        vector)
      (rm)
      room
      (inplen)
      fix
      (inbuf)
      string
      (winner)
      adv
      (av)
      or(
        false,
        object)
      (outchan)
      channel
      (ivec)
      or(
        false,
        vector)
      (vc)
      vector),
  or(
    _ivec,
    prog(
      (),
      put(
        _outchan,
        13,
        1000),
      room_info(
        t))),
  repeat(
    (vval
      cv),
    #decl
      ((cv)
        or(
          false,
          verb)),
    set(
      vval,
      t),
    cond(
      (not(
          _ivec)
        set(
          rm,
          ,here)
        princ(
          ">")
        setg(
          tell_flag,
          <>)
        set(
          inplen,
          readstring(
            _inbuf,
            ,inchan,
            _str))
        readchr(
          ,inchan)
        or(
          ,alt_flag,
          readchr(
            ,inchan))
        set(
          vc,
          lex(
            _inbuf,
            rest(
              _inbuf,
              _inplen),
            t)))),
    cond(
      (g_Q(
          _inplen,
          0)
        setg(
          moves,
          _(
            ,moves,
            1))
        cond(
          (setg(
              parse_won,
              and(
                eparse(
                  or(
                    _ivec,
                    _vc),
                  <>),
                type_Q(
                  set(
                    cv,
                    1(
                      set(
                        rvec,
                        ,prsvec))),
                  verb)))
            cond(
              (not(
                  set(
                    random_action,
                    aaction(
                      _winner)))),
              (apply_random(
                  _random_action)
                return(
                  )))
            and(
              set(
                av,
                avehicle(
                  _winner)),
              set(
                random_action,
                oaction(
                  _av)),
              set(
                vval,
                not(
                  apply_random(
                    _random_action,
                    read_in))))
            cond(
              (and(
                  _vval,
                  set(
                    random_action,
                    vfcn(
                      _cv)),
                  apply_random(
                    _random_action))
                cond(
                  (and(
                      set(
                        random_action,
                        raction(
                          set(
                            rm,
                            ,here))),
                      apply_random(
                        _random_action))))))),
          (_ivec
            cond(
              (,tell_flag
                tell(
                  "Please input entire command again.")),
              (tell(
                  "Nothing happens.")))
            return(
              )))
        or(
          ,tell_flag,
          tell(
            "Nothing happens."))),
      (t
        setg(
          parse_won,
          <>)
        tell(
          "Beg pardon?"))),
    mapf(
      <>,
      function(
        (x),
        #decl
          ((x)
            hack),
        cond(
          (set(
              random_action,
              haction(
                _x))
            apply_random(
              _random_action,
              _x)))),
      ,demons),
    and(
      ,parse_won,
      set(
        av,
        avehicle(
          _winner)),
      set(
        random_action,
        oaction(
          _av)),
      apply_random(
        _random_action,
        read_out)),
    and(
      _ivec,
      return(
        ))))

define(
  score_obj,
  (obj
    "AUX"
    temp),
  #decl
    ((obj)
      object),
  cond(
    (g_Q(
        set(
          temp,
          ofval(
            _obj)),
        0)
      score_upd(
        _temp)
      put(
        _obj,
        ,ofval,
        0))))

define(
  score_room,
  (rm
    "AUX"
    temp),
  #decl
    ((rm)
      room),
  cond(
    (g_Q(
        set(
          temp,
          rval(
            _rm)),
        0)
      score_upd(
        _temp)
      put(
        _rm,
        ,rval,
        0))))

define(
  score_upd,
  (num
    "AUX"
    (winner
      ,winner)),
  #decl
    ((num)
      fix),
  put(
    _winner,
    ,ascore,
    _(
      ascore(
        _winner),
      _num)),
  setg(
    raw_score,
    _(
      ,raw_score,
      _num)))

define(
  score,
  ("OPTIONAL"
    (ask_Q
      t)
    "AUX"
    scor
    (outchan
      _outchan)
    pct),
  #decl
    ((ask_Q)
      or(
        atom,
        false)
      (scor)
      fix
      (outchan)
      channel
      (pct)
      float),
  setg(
    tell_flag,
    t),
  crlf(
    ),
  cond(
    (_ask_Q
      princ(
        "Your score would be")),
    (princ(
        "Your score is"))),
  prin1(
    set(
      scor,
      ascore(
        ,winner))),
  princ(
    "[total of"),
  prin1(
    ,score_max),
  princ(
    "points], in"),
  prin1(
    ,moves),
  cond(
    (1_Q(
        ,moves)
      princ(
        "move.")),
    (princ(
        "moves."))),
  crlf(
    ),
  princ(
    "This score gives you the rank of"),
  set(
    pct,
    _(
      float(
        _scor),
      float(
        ,score_max))),
  princ(
    cond(
      (1_Q(
          _pct)
        "Cheater"),
      (g_Q(
          _pct,
          0_95000000)
        "Wizard"),
      (g_Q(
          _pct,
          0_89999999)
        "Master"),
      (g_Q(
          _pct,
          0_79999999)
        "Winner"),
      (g_Q(
          _pct,
          0_60000000)
        "Hacker"),
      (g_Q(
          _pct,
          0_39999999)
        "Adventurer"),
      (g_Q(
          _pct,
          0_19999999)
        "Junior Adventurer"),
      (g_Q(
          _pct,
          0_09999999)
        "Novice Adventurer"),
      (g_Q(
          _pct,
          0_04999999)
        "Amateur Adventurer"),
      ("Beginner"))),
  princ(
    "."),
  crlf(
    ),
  _scor)

define(
  finish,
  ("OPTIONAL"
    (ask_Q
      t)
    "AUX"
    scor),
  #decl
    ((ask_Q)
      or(
        atom,
        false)
      (scor)
      fix),
  unwind(
    prog(
      (),
      set(
        scor,
        score(
          _ask_Q)),
      cond(
        (or(
            and(
              _ask_Q,
              tell(
                "Do you wish to leave the game? (Y is affirmative):"),
              yes_no(
                <>)),
            not(
              _ask_Q))
          record(
            _scor,
            ,moves,
            ,deaths,
            _ask_Q,
            ,here)
          quit(
            )))),
    quit(
      )))

"PRINT OUT DESCRIPTION OF LOSSAGE:  WHEN PLAYED, SCORE, # MOVES, ETC."

setg(
  record_string,
  istring(
    5))

gdecl(
  (record_string),
  string)

psetg(
  recorder_string,
  string(
    ascii(
      26),
    ascii(
      3),
    ascii(
      0)))

define(
  record,
  record,
  (score
    moves
    deaths
    quit_Q
    loc
    "AUX"
    (ch
      <>)
    (str
      ,record_string)
    fl
    (ct
      0)
    (muddle
      ,muddle)
    (dev
      value(
        dev))
    (snm
      value(
        snm))),
  #decl
    ((muddle
        score
        moves
        deaths)
      fix
      (quit_Q)
      or(
        atom,
        false)
      (loc)
      room
      (ch)
      or(
        channel(
          fix),
        false)
      (str)
      string
      (ct
        fl)
      fix
      (dev
        snm)
      string),
  unwind(
    prog(
      (),
      prog(
        (),
        cond(
          (set(
              ch,
              open(
                "READB",
                "ZORK",
                "LOG",
                _dev,
                _snm))
            cond(
              (g__Q(
                  set(
                    fl,
                    file_length(
                      _ch)),
                  1)
                access(
                  _ch,
                  _(
                    _fl,
                    1))
                set(
                  ct,
                  readstring(
                    _str,
                    _ch,
                    ,recorder_string))))
            close(
              _ch)
            cond(
              (set(
                  ch,
                  open(
                    "PRINTO",
                    "ZORK",
                    "LOG",
                    _dev,
                    _snm))),
              (and(
                  g_Q(
                    _muddle,
                    100),
                  _EQ_Q(
                    3(
                      _ch),
                    _600123_))
                // Can't win--no write access
                return(
                  t,
                  _record)),
              (t
                sleep(
                  1)
                again(
                  )))
            access(
              _ch,
              max(
                0,
                _(
                  _fl,
                  1)))
            printstring(
              _str,
              _ch,
              _ct)),
          (or(
              and(
                l_Q(
                  _muddle,
                  100),
                n_EQ_Q(
                  3(
                    _ch),
                  _4000000_)),
              and(
                g_Q(
                  _muddle,
                  100),
                _EQ_Q(
                  3(
                    _ch),
                  _600130_)))
            // on 10x, must get FILE BUSY to try again
            sleep(
              1)
            again(
              )),
          (set(
              ch,
              open(
                "PRINT",
                "ZORK",
                "LOG",
                _dev,
                _snm))),
          (and(
              g_Q(
                _muddle,
                100),
              _EQ_Q(
                3(
                  _ch),
                _600117_))
            // No write access
            return(
              t,
              _record)),
          (return(
              t,
              _record)))),
      crlf(
        _ch),
      princ(
        "",
        _ch),
      princ(
        ,user_name,
        _ch),
      cond(
        (n__Q(
            ,user_name,
            ,xunm)
          princ(
            "(",
            _ch)
          princ(
            ,xunm,
            _ch)
          princ(
            _X__,
            _ch))),
      princ(
        "",
        _ch),
      pdskdate(
        dskdate(
          ),
        _ch),
      crlf(
        _ch),
      play_time(
        _ch,
        <>),
      crlf(
        _ch),
      prin1(
        _score,
        _ch),
      princ(
        _X__,
        _ch),
      prin1(
        ,score_max,
        _ch),
      princ(
        "points,",
        _ch),
      prin1(
        _moves,
        _ch),
      princ(
        "moves,",
        _ch),
      prin1(
        _deaths,
        _ch),
      princ(
        "death",
        _ch),
      cond(
        (1_Q(
            _deaths)
          princ(
            ".",
            _ch)),
        (t
          princ(
            "s.",
            _ch))),
      princ(
        "In",
        _ch),
      princ(
        rdesc2(
          _loc),
        _ch),
      cond(
        (_quit_Q
          princ(
            ". Quit.",
            _ch)),
        (empty_Q(
            _quit_Q)
          princ(
            ". Died.",
            _ch)),
        (princ(
            1(
              _quit_Q),
            _ch))),
      crlf(
        _ch),
      mapf(
        <>,
        function(
          (x
            y),
          #decl
            ((x)
              atom
              (y)
              string),
          cond(
            (,_x
              princ(
                "/",
                _ch)
              princ(
                _y,
                _ch)))),
        ,flag_names,
        ,short_names),
      mapf(
        <>,
        function(
          (x
            y),
          #decl
            ((x)
              atom
              (y)
              string),
          cond(
            (0_Q(
                ,_x)
              princ(
                "/",
                _ch)
              princ(
                _y,
                _ch)))),
        ,val_names,
        ,short_val_names),
      crlf(
        _ch),
      close(
        _ch)),
    and(
      _ch,
      not(
        0_Q(
          1(
            _ch))),
      close(
        _ch))))

flag_names

gdecl(
  (flag_names
    val_names),
  uvector(
    [rest
      atom]),
  (short_names
    short_val_names),
  vector(
    [rest
      string]))

block(
  (or(
      get(
        flag,
        oblist),
      moblist(
        flag))
    get(
      initial,
      oblist)
    root(
      )))

psetg(
  flag_names,
  uvector(
    kitchen_window,
    troll_flag,
    key_flag,
    low_tide,
    dome_flag,
    glacier_flag,
    echo_flag,
    riddle_flag,
    lld_flag,
    cyclops_flag,
    magic_flag,
    rainbow,
    gnome_door,
    carousel_flip,
    cage_solve))

endblock(
  )

psetg(
  short_names,
  vector(
    "KI",
    "TR",
    "KE",
    "LO",
    "DO",
    "GL",
    "EC",
    "RI",
    "LL",
    "CY",
    "MA",
    "RA",
    "GN",
    "CA",
    "CG"))

psetg(
  val_names,
  uvector(
    light_shaft))

psetg(
  short_val_names,
  vector(
    "LI"))

define(
  pdskdate,
  (wd
    ch
    "AUX"
    (tim
      chtype(
        getbits(
          _wd,
          bits(
            18,
            0)),
        fix))
    (a_p
      "AM")
    hr),
  #decl
    ((wd)
      primtype(
        word)
      (tim
        hr)
      fix
      (a_p)
      string
      (ch)
      channel),
  princ(
    "",
    _ch),
  cond(
    (0_Q(
        chtype(
          _wd,
          fix))
      princ(
        "unknown",
        _ch)),
    (t
      princ(
        nth(
          ,months,
          chtype(
            getbits(
              _wd,
              bits(
                4,
                23)),
            fix)),
        _ch)
      princ(
        "",
        _ch)
      prin1(
        chtype(
          getbits(
            _wd,
            bits(
              5,
              18)),
          fix),
        _ch)
      princ(
        "at",
        _ch)
      set(
        hr,
        _(
          _tim,
          7200))
      cond(
        (g__Q(
            _hr,
            12)
          set(
            hr,
            _(
              _hr,
              12))
          set(
            a_p,
            "PM")))
      cond(
        (0_Q(
            _hr)
          set(
            hr,
            12)))
      prin1(
        _hr,
        _ch)
      princ(
        ":",
        _ch)
      set(
        hr,
        _(
          mod(
            _tim,
            7200),
          120))
      cond(
        (l_Q(
            _hr,
            10)
          princ(
            "0",
            _ch)))
      prin1(
        _hr,
        _ch)
      princ(
        _a_p,
        _ch))))

psetg(
  months,
  ["January"
    "February"
    "March"
    "April"
    "May"
    "June"
    "July"
    "August"
    "September"
    "October"
    "November"
    "December"])

gdecl(
  (months),
  vector(
    [12
      string]))

define(
  jigs_up,
  (desc
    "AUX"
    (winner
      ,winner)
    (deaths
      ,deaths)
    (aobjs
      aobjs(
        _winner))
    (random_list
      ,random_list)
    (lamp
      find_obj(
        "LAMP"))
    lamp_location
    (val_list
      ())
    lc),
  #decl
    ((desc)
      string
      (deaths)
      fix
      (aobjs)
      list(
        [rest
          object])
      (val_list)
      list(
        [rest
          object])
      (lamp_location)
      or(
        false,
        room)
      (winner)
      adv
      (random_list)
      list(
        [rest
          room])
      (lamp)
      object),
  cond(
    (,dbg
      tell(
        _desc)),
    (unwind(
        prog(
          (),
          cond(
            (n_EQ_Q(
                _winner,
                ,player)
              tell(
                _desc)
              tell(
                "The",
                1,
                odesc2(
                  aobj(
                    _winner)),
                "has died.")
              remove_object(
                aobj(
                  _winner))
              put(
                _winner,
                ,aroom,
                find_room(
                  "FCHMP"))
              return(
                ))),
          reset(
            ,inchan),
          score_upd(
            _10),
          put(
            _winner,
            ,avehicle,
            <>),
          cond(
            (g__Q(
                _deaths,
                2)
              tell(
                _desc)
              tell(
                "You clearly are a suicidal maniac.  We don't allow psychotics in the\ncave, since they may harm other adventurers.  Your remains will\ninstalled in the Land of the Living Dead, where your fellow adventurers \nmay gloat over them.")
              finish(
                <>)),
            (setg(
                deaths,
                _(
                  _deaths,
                  1))
              tell(
                _desc)
              tell(
                "Do you want me to try to patch you?",
                0)
              cond(
                (not(
                    yes_no(
                      t))
                  tell(
                    "What?  You don't trust me?  Why, only last week I patched a running ITS\nand it survived for over 30 seconds.  Oh, well.",
                    2)
                  finish(
                    <>)),
                (t
                  tell(
                    "Now, let me see...\nWell, we weren't quite able to restore your state.  You can't have\neverything.")
                  cond(
                    (set(
                        lamp_location,
                        oroom(
                          _lamp))
                      put(
                        _winner,
                        ,aobjs,
                        (_lamp
                          _X_aobjs))
                      cond(
                        (memq(
                            _lamp,
                            robjs(
                              _lamp_location))
                          remove_object(
                            _lamp)),
                        (set(
                            lc,
                            ocan(
                              _lamp))
                          put(
                            _lc,
                            ,ocontents,
                            splice_out(
                              _lamp,
                              ocontents(
                                _lc)))
                          put(
                            _lamp,
                            ,oroom,
                            <>)
                          put(
                            _lamp,
                            ,ocan,
                            <>)))),
                    (memq(
                        _lamp,
                        _aobjs)
                      put(
                        _winner,
                        ,aobjs,
                        (_lamp
                          _X
                          splice_out(
                            _lamp,
                            _aobjs)))))
                  put(
                    find_obj(
                      "DOOR"),
                    ,otouch_Q,
                    <>)
                  goto(
                    find_room(
                      "FORE1"))
                  setg(
                    egypt_flag_X_flag,
                    t)
                  set(
                    val_list,
                    rob_adv(
                      _winner,
                      _val_list))
                  mapf(
                    <>,
                    function(
                      (x
                        y),
                      #decl
                        ((x)
                          object
                          (y)
                          room),
                      insert_object(
                        _x,
                        _y)),
                    set(
                      aobjs,
                      aobjs(
                        _winner)),
                    _random_list)
                  cond(
                    (g__Q(
                        length(
                          _random_list),
                        length(
                          _aobjs))
                      set(
                        aobjs,
                        _val_list)),
                    (empty_Q(
                        _val_list)
                      set(
                        aobjs,
                        rest(
                          _aobjs,
                          length(
                            _random_list)))),
                    (t
                      putrest(
                        rest(
                          _val_list,
                          _(
                            length(
                              _val_list),
                            1)),
                        rest(
                          _aobjs,
                          length(
                            _random_list)))
                      set(
                        aobjs,
                        _val_list)))
                  mapf(
                    <>,
                    function(
                      (x
                        y),
                      #decl
                        ((x)
                          object
                          (y)
                          room),
                      insert_object(
                        _x,
                        _y)),
                    _aobjs,
                    ,rooms)
                  put(
                    _winner,
                    ,aobjs,
                    ())
                  t))))),
        prog(
          (),
          record(
            score(
              <>),
            ,moves,
            ,deaths,
            <>,
            ,here),
          quit(
            ))))))

define(
  info,
  (),
  file_to_tty(
    "MADADV",
    "INFO"))

define(
  help,
  (),
  file_to_tty(
    "MADADV",
    "HELP"))

psetg(
  breaks,
  string(
    ascii(
      3),
    ascii(
      0)))

define(
  file_to_tty,
  (file1
    file2
    "OPTIONAL"
    (dev
      value(
        dev))
    (snm
      value(
        snm))
    "AUX"
    (ch
      open(
        "READ",
        _file1,
        _file2,
        _dev,
        _snm))
    len
    (buf
      ,inbuf)
    (buflen
      length(
        _buf))
    iter),
  #decl
    ((buf
        file1
        file2
        dev
        snm)
      string
      (ch)
      or(
        channel,
        false)
      (iter
        len
        buflen)
      fix),
  cond(
    (_ch
      unwind(
        prog(
          (),
          set(
            len,
            file_length(
              _ch)),
          set(
            iter,
            _(
              _len,
              _buflen)),
          or(
            0_Q(
              mod(
                _len,
                _buflen)),
            set(
              iter,
              _(
                _iter,
                1))),
          crlf(
            ,outchan),
          setg(
            tell_flag,
            t),
          repeat(
            (slen),
            #decl
              ((slen)
                fix),
            cond(
              (1_Q(
                  _iter)
                set(
                  slen,
                  readstring(
                    _buf,
                    _ch,
                    ,breaks))),
              (set(
                  slen,
                  readstring(
                    _buf,
                    _ch,
                    _buflen)))),
            printstring(
              _buf,
              ,outchan,
              _slen),
            cond(
              (0_Q(
                  set(
                    iter,
                    _(
                      _iter,
                      1)))
                crlf(
                  ,outchan)
                return(
                  close(
                    _ch)))))),
        close(
          _ch))),
    (tell(
        "File not found."))))

define(
  invent,
  ("OPTIONAL"
    (win
      ,winner)
    "AUX"
    (any
      <>)
    (outchan
      ,outchan)),
  #decl
    ((any)
      or(
        atom,
        false)
      (outchan)
      channel
      (win)
      adv),
  mapf(
    <>,
    function(
      (x),
      #decl
        ((x)
          object),
      cond(
        (ovis_Q(
            _x)
          or(
            _any,
            prog(
              (),
              cond(
                (_EQ_Q(
                    _win,
                    ,player)
                  tell(
                    "You are carrying:")),
                (tell(
                    "The",
                    1,
                    odesc2(
                      aobj(
                        _win)),
                    "is carrying:"))),
              set(
                any,
                t)))
          tell(
            "A",
            0,
            odesc2(
              _x))
          cond(
            (or(
                empty_Q(
                  ocontents(
                    _x)),
                not(
                  see_inside_Q(
                    _x)))),
            (tell(
                "with",
                0)
              print_contents(
                ocontents(
                  _x))))
          crlf(
            )))),
    aobjs(
      _win)),
  or(
    _any,
    n_EQ_Q(
      _win,
      ,player),
    tell(
      "You are empty handed.")))

define(
  print_contents,
  (olst
    "AUX"
    (outchan
      ,outchan)),
  #decl
    ((olst)
      list(
        [rest
          object])
      (outchan)
      channel),
  mapr(
    <>,
    function(
      (y),
      #decl
        ((y)
          list(
            [rest
              object])),
      princ(
        "a"),
      princ(
        odesc2(
          1(
            _y))),
      cond(
        (g_Q(
            length(
              _y),
            2)
          princ(
            ",")),
        (_EQ_Q(
            length(
              _y),
            2)
          princ(
            ", and")))),
    _olst))

// LIT? --  IS THERE ANY LIGHT SOURCE IN THIS ROOM

define(
  lit_Q,
  (rm
    "AUX"
    (win
      ,winner)),
  #decl
    ((rm)
      room
      (win)
      adv),
  or(
    rlight_Q(
      _rm),
    lfcn(
      robjs(
        _rm)),
    lfcn(
      aobjs(
        _win)),
    and(
      n_EQ_Q(
        _win,
        ,player),
      _EQ_Q(
        ,here,
        aroom(
          ,player)),
      lfcn(
        aobjs(
          ,player)))))

define(
  lfcn,
  lfcn,
  (l
    "AUX"
    y),
  #decl
    ((l)
      list(
        [rest
          object])
      (y)
      adv),
  mapf(
    <>,
    function(
      (x),
      #decl
        ((x)
          object),
      and(
        g_Q(
          olight_Q(
            _x),
          0),
        mapleave(
          t)),
      cond(
        (and(
            ovis_Q(
              _x),
            or(
              oopen_Q(
                _x),
              transparent_Q(
                _x)))
          mapf(
            <>,
            function(
              (x),
              #decl
                ((x)
                  object),
              cond(
                (g_Q(
                    olight_Q(
                      _x),
                    0)
                  return(
                    t,
                    _lfcn)))),
            ocontents(
              _x)))),
      cond(
        (and(
            trnn(
              _x,
              ,actorbit),
            lfcn(
              aobjs(
                set(
                  y,
                  orand(
                    _x)))))
          mapleave(
            t)))),
    _l))

// WALK --  GIVEN A DIRECTION, WILL ATTEMPT TO WALK THERE

define(
  walk,
  ("AUX"
    leavings
    nrm
    (where
      chtype(
        2(
          ,prsvec),
        atom))
    (me
      ,winner)
    (rm
      1(
        _me))
    nl
    random_action
    cxs),
  #decl
    ((where)
      atom
      (me)
      adv
      (rm)
      room
      (leavings)
      or(
        atom,
        room,
        cexit,
        nexit)
      (nrm)
      or(
        false,
        <primtype(
            vector)
          [rest
            atom
            or(
              room,
              nexit,
              cexit)]>)
      (nl)
      or(
        atom,
        room,
        false)),
  cond(
    (and(
        _EQ_Q(
          _me,
          ,player),
        not(
          lit_Q(
            _rm)),
        prob(
          75))
      cond(
        (set(
            nrm,
            memq(
              _where,
              rexits(
                _rm)))
          set(
            leavings,
            2(
              _nrm))
          cond(
            (and(
                type_Q(
                  _leavings,
                  room),
                lit_Q(
                  _leavings))
              and(
                goto(
                  _leavings),
                room_info(
                  <>))),
            (and(
                type_Q(
                  _leavings,
                  cexit),
                set(
                  leavings,
                  cond(
                    (and(
                        set(
                          random_action,
                          cxaction(
                            _leavings)),
                        apply_random(
                          _random_action))),
                    (,cxflag(
                          _leavings)
                      cxroom(
                        _leavings)))),
                lit_Q(
                  _leavings))
              or(
                type_Q(
                  _leavings,
                  atom),
                and(
                  goto(
                    _leavings),
                  room_info(
                    <>)))),
            (jigs_up(
                "Oh, no!  A fearsome grue slithered into the room and devoured you.")))),
        (jigs_up(
            "Oh, no!  You walked into the slavering fangs of a lurking grue.")))),
    (set(
        nrm,
        memq(
          _where,
          rexits(
            _rm)))
      set(
        leavings,
        2(
          _nrm))
      cond(
        (type_Q(
            _leavings,
            room)
          and(
            goto(
              _leavings),
            room_info(
              <>))),
        (type_Q(
            _leavings,
            cexit)
          cond(
            (or(
                and(
                  set(
                    random_action,
                    cxaction(
                      _leavings)),
                  set(
                    nl,
                    apply_random(
                      _random_action))),
                and(
                  ,cxflag(
                      _leavings),
                  set(
                    nl,
                    cxroom(
                      _leavings))))
              or(
                type_Q(
                  _nl,
                  atom),
                and(
                  goto(
                    _nl),
                  room_info(
                    <>)))),
            (set(
                cxs,
                cxstr(
                  _leavings))
              or(
                empty_Q(
                  _cxs),
                tell(
                  _cxs))),
            (tell(
                "There is no way to go in that direction.")))),
        (t
          tell(
            _leavings)))),
    (tell(
        "There is no way to go in that direction."))))

define(
  take,
  ("OPTIONAL"
    (take_Q
      t)
    "AUX"
    (win
      ,winner)
    (vec
      ,prsvec)
    (rm
      aroom(
        _win))
    nobj
    (obj
      2(
        _vec))
    (getter_Q
      <>)
    (robjs
      robjs(
        _rm))
    (aobjs
      aobjs(
        _win))
    (load_max
      ,load_max)),
  #decl
    ((win)
      adv
      (vec)
      vector
      (obj
        nobj)
      object
      (rm)
      room
      (getter_Q
        take_Q)
      or(
        atom,
        false)
      (load_max)
      fix
      (robjs
        aobjs)
      list(
        [rest
          object])),
  prog(
    (),
    cond(
      (trnn(
          _obj,
          ,no_check_bit)
        return(
          object_action(
            )))),
    cond(
      (ocan(
          _obj)
        set(
          nobj,
          ocan(
            _obj))
        cond(
          (see_inside_Q(
              _nobj)
            cond(
              (oopen_Q(
                  _nobj)
                set(
                  getter_Q,
                  t)),
              (tell(
                  "I can't reach that.")
                return(
                  <>)))),
          (tell(
              "I can't see one here.")
            return(
              <>))))),
    cond(
      (_EQ_Q(
          _obj,
          avehicle(
            _win))
        tell(
          "You are in it, loser!")
        return(
          <>)),
      (not(
          can_take_Q(
            _obj))
        or(
          apply_object(
            _obj),
          tell(
            pick_one(
              ,yuks)))
        return(
          <>)),
      (or(
          _getter_Q,
          memq(
            _obj,
            _robjs))
        set(
          load_max,
          _(
            _load_max,
            fix(
              _(
                _(
                  1_0,
                  _load_max),
                astrength(
                  _win)))))
        cond(
          (and(
              _getter_Q,
              memq(
                _nobj,
                _aobjs))),
          (g_Q(
              _(
                weight(
                  _aobjs),
                weight(
                  ocontents(
                    _obj)),
                osize(
                  _obj)),
              _load_max)
            tell(
              "Your load is too heavy.  You will have to leave something behind.")
            return(
              <>)))
        cond(
          (not(
              apply_object(
                _obj))
            cond(
              (_getter_Q
                put(
                  _nobj,
                  ,ocontents,
                  splice_out(
                    _obj,
                    ocontents(
                      _nobj)))
                put(
                  _obj,
                  ,oroom,
                  <>)
                put(
                  _obj,
                  ,ocan,
                  <>)),
              (remove_object(
                  _obj)))
            put(
              _win,
              ,aobjs,
              (_obj
                _X_aobjs))
            put(
              _obj,
              ,otouch_Q,
              t)
            score_obj(
              _obj)
            cond(
              (_take_Q
                tell(
                  "Taken.")),
              (t))),
          (t))),
      (memq(
          _obj,
          _aobjs)
        tell(
          "You already have it.")),
      (tell(
          "I can't see one here.")
        <>))))

define(
  putter,
  ("OPTIONAL"
    (objact
      t)
    "AUX"
    (pv
      ,prsvec)
    (objo
      2(
        _pv))
    (obji
      3(
        _pv))
    (win
      ,winner)
    (aobjs
      aobjs(
        _win))
    crock
    can
    (robjs
      robjs(
        ,here))
    (ocan
      <>)),
  #decl
    ((pv)
      vector(
        [3
          any])
      (objo
        obji)
      object
      (win)
      adv
      (aobjs
        robjs)
      list(
        [rest
          object])
      (crock
        can)
      object
      (ocan)
      or(
        false,
        object)
      (objact)
      or(
        atom,
        false)),
  prog(
    (),
    cond(
      (trnn(
          _objo,
          ,no_check_bit)
        return(
          object_action(
            )))),
    cond(
      (or(
          memq(
            _objo,
            ,stars),
          memq(
            _obji,
            ,stars))
        tell(
          "Nice try.")
        return(
          <>))),
    cond(
      (or(
          oopen_Q(
            _obji),
          openable_Q(
            _obji),
          trnn(
            _obji,
            ,vehbit))
        set(
          can,
          _obji)
        set(
          crock,
          _objo)),
      (tell(
          "I can't do that.")
        return(
          <>))),
    cond(
      (not(
          oopen_Q(
            _can))
        tell(
          "I can't reach inside.")
        return(
          <>)),
      (_EQ_Q(
          _can,
          _crock)
        tell(
          "How can you do that?")
        return(
          <>)),
      (g_Q(
          _(
            weight(
              ocontents(
                _can)),
            osize(
              _crock)),
          ocapac(
            _can))
        tell(
          "It won't fit.")
        return(
          <>))),
    cond(
      (or(
          memq(
            _crock,
            _robjs),
          and(
            set(
              ocan,
              ocan(
                _crock)),
            memq(
              _ocan,
              _robjs)),
          and(
            _ocan,
            set(
              ocan,
              ocan(
                _ocan)),
            memq(
              _ocan,
              _robjs)))
        put(
          _pv,
          1,
          ,take_X_words)
        put(
          _pv,
          2,
          _crock)
        put(
          _pv,
          3,
          <>)
        cond(
          (not(
              take(
                <>))
            return(
              <>)),
          (set(
              aobjs,
              aobjs(
                _win))))),
      (set(
          ocan,
          ocan(
            _crock))
        cond(
          (oopen_Q(
              _ocan)
            put(
              _win,
              ,aobjs,
              set(
                aobjs,
                (_crock
                  _X_aobjs)))
            put(
              _ocan,
              ,ocontents,
              splice_out(
                _crock,
                ocontents(
                  _ocan)))
            put(
              _crock,
              ,ocan,
              <>)),
          (tell(
              "I can't reach the",
              1,
              odesc2(
                _crock))
            return(
              <>))))),
    put(
      _pv,
      1,
      ,put_X_words),
    put(
      _pv,
      2,
      _crock),
    put(
      _pv,
      3,
      _can),
    cond(
      (and(
          _objact,
          object_action(
            ))
        return(
          )),
      (put(
          _win,
          ,aobjs,
          splice_out(
            _crock,
            _aobjs))
        put(
          _can,
          ,ocontents,
          (_crock
            _X
            ocontents(
              _can)))
        put(
          _crock,
          ,ocan,
          _can)
        put(
          _crock,
          ,oroom,
          ,here)
        tell(
          "Done.")))))

define(
  dropper,
  ("AUX"
    (winner
      ,winner)
    (av
      avehicle(
        _winner))
    (aobjs
      aobjs(
        _winner))
    (getter_Q
      <>)
    (vec
      ,prsvec)
    (rm
      aroom(
        _winner))
    (obj
      2(
        _vec))
    (pi
      3(
        _vec))
    nobj),
  #decl
    ((vec)
      vector(
        verb,
        object,
        or(
          false,
          object))
      (obj
        nobj)
      object
      (pi
        av)
      or(
        false,
        object)
      (rm)
      room
      (getter_Q)
      or(
        atom,
        false)),
  prog(
    (),
    cond(
      (and(
          memq(
            vname(
              1(
                _vec)),
            () => [drop_X_words
                pour_X_words]),
          _pi)
        put(
          _vec,
          1,
          ,put_X_words)
        return(
          putter(
            ))),
      (and(
          _pi,
          not(
            or(
              memq(
                _obj,
                _aobjs),
              memq(
                ocan(
                  _obj),
                _aobjs))))
        put(
          _vec,
          2,
          _pi)
        put(
          _vec,
          3,
          _obj)
        set(
          obj,
          2(
            _vec)))),
    cond(
      (trnn(
          _obj,
          ,no_check_bit)
        return(
          object_action(
            )))),
    cond(
      (and(
          ocan(
            _obj),
          set(
            nobj,
            ocan(
              _obj)),
          memq(
            _nobj,
            _aobjs))
        cond(
          (oopen_Q(
              _nobj)
            set(
              getter_Q,
              t)),
          (transparent_Q(
              _nobj)
            tell(
              "I can't reach that.")
            return(
              )),
          (tell(
              "I can't see that here."))))),
    cond(
      (or(
          _getter_Q,
          memq(
            _obj,
            _aobjs))
        cond(
          (_av),
          (_getter_Q
            put(
              _nobj,
              ,ocontents,
              splice_out(
                _obj,
                ocontents(
                  _nobj)))
            put(
              _obj,
              ,ocan,
              <>)),
          (put(
              _winner,
              ,aobjs,
              splice_out(
                _obj,
                _aobjs))))
        cond(
          (_av
            put(
              _vec,
              2,
              _obj)
            put(
              _vec,
              3,
              _av)
            putter(
              <>)),
          (insert_object(
              _obj,
              _rm)))
        cond(
          (object_action(
              )),
          (_EQ_Q(
              vname(
                1(
                  _vec)),
              drop_X_words)
            tell(
              "Dropped.")),
          (_EQ_Q(
              vname(
                1(
                  _vec)),
              throw_X_words)
            tell(
              "Thrown.")))),
      (tell(
          "You are not carrying that.")))))

"STUFF FOR 'EVERYTHING' AND 'VALUABLES'"

setg(
  obj_uv,
  chutype(
    rest(
      iuvector(
        20),
      20),
    object))

gdecl(
  (obj_uv),
  uvector(
    [rest
      object]))

define(
  frob_lots,
  (uv
    "AUX"
    (prsvec
      ,prsvec)
    (pa
      1(
        _prsvec))
    (ra
      vfcn(
        _pa))
    pi
    (winner
      ,winner)
    (here
      ,here)),
  #decl
    ((uv)
      uvector(
        [rest
          object])
      (prsvec)
      vector(
        verb,
        [2
          any])
      (pa)
      verb
      (ra)
      rapplic
      (pi)
      or(
        object,
        false)
      (winner)
      adv
      (here)
      room),
  cond(
    (_EQ_Q(
        _pa,
        ,take_X_words)
      mapf(
        <>,
        function(
          (x),
          #decl
            ((x)
              object),
          cond(
            (or(
                can_take_Q(
                  _x),
                trnn(
                  _x,
                  ,trytakebit))
              put(
                _prsvec,
                2,
                _x)
              tell(
                odesc2(
                  _x),
                0,
                ":")
              apply_random(
                _ra)
              cond(
                (n_EQ_Q(
                    _here,
                    aroom(
                      _winner))
                  mapleave(
                    )))))),
        _uv)),
    (or(
        _EQ_Q(
          _pa,
          ,drop_X_words),
        _EQ_Q(
          _pa,
          ,put_X_words))
      mapf(
        <>,
        function(
          (x),
          #decl
            ((x)
              object),
          put(
            _prsvec,
            2,
            _x),
          tell(
            odesc2(
              _x),
            0,
            ":"),
          apply_random(
            _ra),
          cond(
            (n_EQ_Q(
                _here,
                aroom(
                  _winner))
              mapleave(
                )))),
        _uv))),
  t)

psetg(
  losstr,
  "I can't do everything, because I ran out of room.")

define(
  everything,
  ("AUX"
    (prsvec
      ,prsvec)
    (pa
      1(
        _prsvec))
    pi
    (suv
      ,obj_uv)
    (tuv
      top(
        _suv))
    (lu
      length(
        _tuv))
    (here
      ,here)
    (winner
      ,winner)),
  #decl
    ((pa)
      verb
      (suv
        tuv)
      uvector(
        [rest
          object])
      (lu)
      fix
      (here)
      room
      (winner)
      adv
      (pi)
      object),
  cond(
    (_EQ_Q(
        _pa,
        ,take_X_words)
      mapf(
        <>,
        function(
          (x),
          #decl
            ((x)
              object),
          cond(
            (and(
                ovis_Q(
                  _x),
                not(
                  trnn(
                    _x,
                    ,actorbit)))
              cond(
                (_EQ_Q(
                    _suv,
                    _tuv)
                  tell(
                    ,losstr)
                  mapleave(
                    )))
              set(
                suv,
                back(
                  _suv))
              put(
                _suv,
                1,
                _x)))),
        robjs(
          _here))),
    (_EQ_Q(
        _pa,
        ,drop_X_words)
      mapf(
        <>,
        function(
          (x),
          #decl
            ((x)
              object),
          set(
            suv,
            back(
              _suv)),
          put(
            _suv,
            1,
            _x)),
        aobjs(
          _winner))),
    (_EQ_Q(
        _pa,
        ,put_X_words)
      set(
        pi,
        3(
          _prsvec))
      prog(
        rp,
        (),
        mapf(
          <>,
          function(
            (x),
            #decl
              ((x)
                object),
            cond(
              (and(
                  ovis_Q(
                    _x),
                  n_EQ_Q(
                    _x,
                    _pi),
                  not(
                    trnn(
                      _x,
                      ,actorbit)))
                cond(
                  (_EQ_Q(
                      _suv,
                      _tuv)
                    tell(
                      ,losstr)
                    return(
                      t,
                      _rp)))
                set(
                  suv,
                  back(
                    _suv))
                put(
                  _suv,
                  1,
                  _x)))),
          robjs(
            _here)),
        mapf(
          <>,
          function(
            (x),
            #decl
              ((x)
                object),
            cond(
              (and(
                  _EQ_Q(
                    _suv,
                    _tuv),
                  n_EQ_Q(
                    _x,
                    _pi))
                tell(
                  ,losstr)
                return(
                  t,
                  _rp))),
            set(
              suv,
              back(
                _suv)),
            put(
              _suv,
              1,
              _x)),
          aobjs(
            _winner))))),
  cond(
    (empty_Q(
        _suv)
      tell(
        "I couldn't find anything.")),
    (frob_lots(
        _suv))))

define(
  valuables,
  ("AUX"
    (prsvec
      ,prsvec)
    (pa
      1(
        _prsvec))
    (suv
      ,obj_uv)
    (tuv
      top(
        _suv))
    pi
    (lu
      length(
        _tuv))
    (here
      ,here)
    (winner
      ,winner)),
  #decl
    ((pa)
      verb
      (suv
        tuv)
      uvector(
        [rest
          object])
      (lu)
      fix
      (here)
      room
      (winner)
      adv
      (pi)
      object),
  cond(
    (_EQ_Q(
        _pa,
        ,take_X_words)
      mapf(
        <>,
        function(
          (x),
          #decl
            ((x)
              object),
          cond(
            (and(
                ovis_Q(
                  _x),
                not(
                  trnn(
                    _x,
                    ,actorbit)),
                not(
                  0_Q(
                    otval(
                      _x))))
              cond(
                (_EQ_Q(
                    _suv,
                    _tuv)
                  tell(
                    ,losstr)
                  mapleave(
                    )))
              set(
                suv,
                back(
                  _suv))
              put(
                _suv,
                1,
                _x)))),
        robjs(
          _here))),
    (_EQ_Q(
        _pa,
        ,drop_X_words)
      mapf(
        <>,
        function(
          (x),
          #decl
            ((x)
              object),
          cond(
            (not(
                0_Q(
                  otval(
                    _x)))
              set(
                suv,
                back(
                  _suv))
              put(
                _suv,
                1,
                _x)))),
        aobjs(
          _winner))),
    (_EQ_Q(
        _pa,
        ,put_X_words)
      set(
        pi,
        3(
          _prsvec))
      prog(
        rp,
        (),
        mapf(
          <>,
          function(
            (x),
            #decl
              ((x)
                object),
            cond(
              (and(
                  _EQ_Q(
                    _suv,
                    _tuv),
                  n_EQ_Q(
                    _x,
                    _pi))
                tell(
                  ,losstr)
                return(
                  t,
                  _rp))),
            cond(
              (and(
                  ovis_Q(
                    _x),
                  not(
                    0_Q(
                      otval(
                        _x))))
                set(
                  suv,
                  back(
                    _suv))
                put(
                  _suv,
                  1,
                  _x)))),
          robjs(
            _here)),
        mapf(
          <>,
          function(
            (x),
            #decl
              ((x)
                object),
            cond(
              (and(
                  _EQ_Q(
                    _suv,
                    _tuv),
                  n_EQ_Q(
                    _x,
                    _pi))
                tell(
                  ,losstr)
                return(
                  t,
                  _rp))),
            cond(
              (not(
                  0_Q(
                    otval(
                      _x)))
                set(
                  suv,
                  back(
                    _suv))
                put(
                  _suv,
                  1,
                  _x)))),
          aobjs(
            _winner))))),
  cond(
    (empty_Q(
        _suv)
      tell(
        "I couldn't find any valuables.")),
    (frob_lots(
        _suv))))

define(
  opener,
  open_act,
  ("AUX"
    (pv
      ,prsvec)
    (prso
      2(
        _pv))
    (outchan
      ,outchan)),
  #decl
    ((prso)
      object
      (pv)
      vector(
        [3
          any])
      (outchan)
      channel),
  cond(
    (object_action(
        )),
    (not(
        trnn(
          _prso,
          ,contbit))
      tell(
        "You must tell me how to do that to a",
        1,
        odesc2(
          _prso),
        ".")),
    (n_EQ_Q(
        ocapac(
          _prso),
        0)
      cond(
        (oopen_Q(
            _prso)
          tell(
            "It is already open.")),
        (t
          put(
            _prso,
            ,oopen_Q,
            t)
          cond(
            (or(
                empty_Q(
                  ocontents(
                    _prso)),
                transparent_Q(
                  _prso))
              tell(
                "Opened.")),
            (setg(
                tell_flag,
                t)
              tell(
                "Opening the",
                0,
                odesc2(
                  _prso),
                "reveals")
              print_contents(
                ocontents(
                  _prso))
              princ(
                _X__)
              crlf(
                )))))),
    (tell(
        "The",
        1,
        odesc2(
          _prso),
        "cannot be opened."))))

define(
  closer,
  close_act,
  ("AUX"
    (pv
      ,prsvec)
    (prso
      2(
        _pv))),
  #decl
    ((pv)
      vector(
        [3
          any])
      (prso)
      object),
  cond(
    (object_action(
        )),
    (not(
        trnn(
          _prso,
          ,contbit))
      tell(
        "You must tell me how to do that to a",
        1,
        odesc2(
          _prso),
        ".")),
    (n_EQ_Q(
        ocapac(
          _prso),
        0)
      cond(
        (oopen_Q(
            _prso)
          put(
            _prso,
            ,oopen_Q,
            <>)
          tell(
            "Closed.")),
        (t
          tell(
            "It is already closed.")))),
    (tell(
        "You cannot close that."))))

define(
  find,
  ("AUX"
    (prso
      2(
        ,prsvec))),
  #decl
    ((prso)
      or(
        false,
        object)),
  cond(
    (object_action(
        )),
    (_prso
      find_frob(
        _prso,
        robjs(
          ,here),
        ", which is in the room.",
        "There is a",
        "here.")
      find_frob(
        _prso,
        aobjs(
          ,winner),
        ", which you are carrying.",
        "You are carrying a",
        ".")
      cond(
        (not(
            ,tell_flag)
          tell(
            "I can't see that here.")))),
    (tell(
        "I don't know what that is."))))

define(
  find_frob,
  (prso
    objl
    str1
    str2
    str3),
  #decl
    ((obj)
      object
      (objl)
      list(
        [rest
          object])
      (str1
        str2
        str3)
      string),
  mapf(
    <>,
    function(
      (x),
      #decl
        ((x)
          object),
      cond(
        (_EQ_Q(
            _x,
            _prso)
          tell(
            _str2,
            1,
            odesc2(
              _x),
            _str3)),
        (or(
            transparent_Q(
              _x),
            and(
              openable_Q(
                _x),
              oopen_Q(
                _x)))
          mapf(
            <>,
            function(
              (y),
              #decl
                ((y)
                  object),
              cond(
                (_EQ_Q(
                    _y,
                    _prso)
                  tell(
                    _str2,
                    1,
                    odesc2(
                      _y),
                    _str3)
                  tell(
                    "It is in the",
                    1,
                    odesc2(
                      _x),
                    _str1)))),
            ocontents(
              _x))))),
    _objl))

// OBJECT-ACTION --  CALL OBJECT FUNCTIONS FOR DIRECT AND INDIRECT OBJECTS

define(
  object_action,
  ("AUX"
    (vec
      ,prsvec)
    (prso
      2(
        _vec))
    (prsi
      3(
        _vec))),
  #decl
    ((prso
        prsi)
      or(
        object,
        false)
      (vec)
      vector),
  prog(
    (),
    cond(
      (_prsi
        and(
          apply_object(
            _prsi),
          return(
            t)))),
    cond(
      (_prso
        apply_object(
          _prso)))))

"SIMPLE OBJ-HERE:  IS IT IN THE ROOM OR IN THE GUY'S HAND.  TO DO FULL\nSEARCH, USE GET-OBJECT"

define(
  obj_here_Q,
  (obj
    "AUX"
    nobj
    (rm
      ,here)
    (win
      ,winner)),
  #decl
    ((obj)
      object
      (rm)
      room
      (win)
      adv
      (nobj)
      or(
        false,
        object)),
  prog(
    (),
    cond(
      (not(
          ovis_Q(
            _obj))
        return(
          <>)),
      (set(
          nobj,
          ocan(
            _obj))
        cond(
          (oopen_Q(
              _nobj)
            set(
              obj,
              _nobj)),
          (return(
              <>))))),
    or(
      memq(
        _obj,
        robjs(
          _rm)),
      memq(
        _obj,
        aobjs(
          _win)))))

define(
  splice_out,
  (obj
    al),
  #decl
    ((al)
      list),
  cond(
    (_EQ_Q(
        1(
          _al),
        _obj)
      rest(
        _al)),
    (t
      repeat(
        ((nl
            rest(
              _al))
          (ol
            _al)),
        #decl
          ((nl
              ol)
            list),
        cond(
          (_EQ_Q(
              1(
                _nl),
              _obj)
            putrest(
              _ol,
              rest(
                _nl))
            return(
              _al)),
          (set(
              ol,
              _nl)
            set(
              nl,
              rest(
                _nl))))))))

"WEIGHT:  Get sum of OSIZEs of supplied list, recursing to the nth level."

define(
  weight,
  (objl
    "AUX"
    (bigfix
      ,bigfix)),
  #decl
    ((objl)
      list(
        [rest
          object])
      (bigfix)
      fix
      (value)
      fix),
  mapf(
    ,_,
    function(
      (obj),
      #decl
        ((obj)
          object),
      _(
        cond(
          (_EQ_Q(
              osize(
                _obj),
              ,bigfix)
            0),
          (osize(
              _obj))),
        weight(
          ocontents(
            _obj)))),
    _objl))

define(
  pour,
  (),
  t)

define(
  move,
  ("AUX"
    (vec
      ,prsvec)
    (rm
      aroom(
        ,winner))
    (obj
      2(
        _vec))),
  #decl
    ((vec)
      vector
      (rm)
      room
      (obj)
      or(
        atom,
        object)),
  cond(
    (memq(
        _obj,
        robjs(
          _rm))
      object_action(
        )),
    (_obj
      tell(
        "I can't get to that to move it."))))

define(
  victims_Q,
  (rm),
  #decl
    ((rm)
      room),
  mapf(
    <>,
    function(
      (x),
      #decl
        ((x)
          object),
      cond(
        (trnn(
            _x,
            ,vicbit)
          mapleave(
            _x)))),
    robjs(
      _rm)))

define(
  lamp_on,
  lampo,
  ("AUX"
    (prsvec
      ,prsvec)
    (me
      ,winner)
    (obj
      2(
        _prsvec))
    (lit_Q
      lit_Q(
        ,here))),
  #decl
    ((me)
      adv
      (obj)
      object
      (lampo)
      activation),
  cond(
    (and(
        trnn(
          _obj,
          ,burnbit),
        3(
          _prsvec),
        put(
          _prsvec,
          1,
          ,burn_X_words))
      burner(
        )),
    (object_action(
        )),
    (cond(
        (and(
            n_EQ_Q(
              olight_Q(
                _obj),
              0),
            memq(
              _obj,
              aobjs(
                _me)))),
        (t
          tell(
            "You can't turn that on.")
          return(
            t,
            _lampo)))
      cond(
        (g_Q(
            olight_Q(
              _obj),
            0)
          tell(
            "It is already on.")),
        (put(
            _obj,
            ,olight_Q,
            1)
          tell(
            "The",
            1,
            odesc2(
              _obj),
            "is now on.")
          cond(
            (not(
                _lit_Q)
              put(
                ,prsvec,
                2,
                <>)
              room_info(
                <>))))))))

define(
  lamp_off,
  lampo,
  ("AUX"
    (me
      ,winner)
    (obj
      2(
        ,prsvec))),
  #decl
    ((me)
      adv
      (obj)
      object
      (lampo)
      activation),
  cond(
    (object_action(
        )),
    (cond(
        (and(
            n_EQ_Q(
              olight_Q(
                _obj),
              0),
            memq(
              _obj,
              aobjs(
                _me)))),
        (tell(
            "You can't turn that off.")
          return(
            t,
            _lampo)))
      cond(
        (l_Q(
            olight_Q(
              _obj),
            0)
          tell(
            "It is already off.")),
        (put(
            _obj,
            ,olight_Q,
            _1)
          tell(
            "The",
            1,
            odesc2(
              _obj),
            "is now off.")
          or(
            lit_Q(
              ,here),
            tell(
              "It is now pitch black.")))))))

"PARSER & AUXILIARIES"

setg(
  inbuf,
  istring(
    100))

// SET UP INPUT ERROR HANDLER TO CAUSE EPARSE TO FALSE OUT

psetg(
  cntprs,
  "I can't parse that.")

setg(
  prsvec,
  ivector(
    3,
    #false
      ()))

define(
  word_Q,
  (w),
  lookup(
    _w,
    ,words))

define(
  this_it_Q,
  (objnam
    obj
    adj),
  #decl
    ((objnam)
      atom
      (obj)
      object
      (adj)
      or(
        false,
        adjective)),
  cond(
    (and(
        ovis_Q(
          _obj),
        or(
          _EQ_Q(
            _objnam,
            oid(
              _obj)),
          memq(
            _objnam,
            onames(
              _obj))))
      cond(
        (not(
            _adj)),
        (memq(
            _adj,
            oadjs(
              _obj)))))))

setg(
  lexv,
  ivector(
    10,
    () => rest(
        istring(
          5),
        5)))

gdecl(
  (lexv),
  vector(
    [rest
      string]),
  (brks),
  string)

define(
  lex,
  (s
    "OPTIONAL"
    (sx
      rest(
        _s,
        length(
          _s)))
    (silent_Q
      <>)
    "AUX"
    (brks
      ,brks)
    (v
      ,lexv)
    (s1
      _s)
    (quot
      <>)),
  #decl
    ((s
        s1
        sx
        brks)
      string
      (silent_Q
        quot)
      or(
        atom,
        false)
      (value)
      or(
        false,
        vector)
      (v)
      vector(
        [rest
          string])),
  mapr(
    <>,
    function(
      (x
        "AUX"
        (str
          1(
            _x))),
      #decl
        ((x)
          vector(
            [rest
              string])
          (str)
          string),
      put(
        _x,
        1,
        rest(
          _str,
          length(
            _str)))),
    _v),
  cond(
    (_EQ_Q(
        1(
          _s),
        _X__Q)
      put(
        _v,
        1,
        substruc(
          "HELP",
          0,
          4,
          back(
            1(
              _v),
            4)))),
    (repeat(
        (slen),
        #decl
          ((slen)
            fix),
        cond(
          (or(
              _EQ_Q(
                length(
                  _s1),
                length(
                  _sx)),
              memq(
                1(
                  _s1),
                _brks))
            and(
              g_Q(
                length(
                  _s1),
                length(
                  _sx)),
              or(
                _EQ_Q(
                  1(
                    _s1),
                  _X__),
                _EQ_Q(
                  1(
                    _s1),
                  _X__)),
              not(
                _quot),
              set(
                quot,
                t),
              set(
                v,
                rest(
                  _v)))
            cond(
              (n_EQ_Q(
                  _s,
                  _s1)
                cond(
                  (empty_Q(
                      _v)
                    or(
                      _silent_Q,
                      tell(
                        "I'm too simple-minded for that."))),
                  (put(
                      _v,
                      1,
                      uppercase(
                        substruc(
                          _s,
                          0,
                          set(
                            slen,
                            min(
                              _(
                                length(
                                  _s),
                                length(
                                  _s1)),
                              5)),
                          back(
                            1(
                              _v),
                            _slen))))
                    set(
                      v,
                      rest(
                        _v))))))
            cond(
              (_EQ_Q(
                  length(
                    _s1),
                  length(
                    _sx))
                return(
                  _v)))
            set(
              s,
              rest(
                _s1)))),
        set(
          s1,
          rest(
            _s1))))),
  ,lexv)

psetg(
  brks,
  "\"' 	:;.,?!")

define(
  anything,
  (s
    sx),
  #decl
    ((s
        sx)
      string),
  mapr(
    <>,
    \* FUNCTION *\
      (x) => (
      cond,
      (_EQ_Q(
            _x,
            _sx)
          mapleave(
            <>)),
      (not(
            memq(
              1(
                _x),
              ,brks))
          mapleave(
            _x))),
    _s))

define(
  uppercase,
  (str),
  #decl
    ((str)
      string),
  mapr(
    <>,
    \* FUNCTION *\
      (s,
      "AUX",
      (c
          ascii(
            1(
              _s)))) => (
      cond,
      (and(
            g_Q(
              _c,
              96),
            l__Q(
              _c,
              122))
          put(
            _s,
            1,
            ascii(
              _(
                _c,
                32))))),
    _str),
  _str)

define(
  wait,
  ("OPTIONAL"
    (num
      3)),
  #decl
    ((num)
      fix),
  tell(
    "Time passes..."),
  repeat(
    ((n
        _num)),
    #decl
      ((n)
        fix),
    cond(
      (or(
          l_Q(
            set(
              n,
              _(
                _n,
                1)),
            0),
          clock_demon(
            ,clocker))
        return(
          )))))

"RUNS ONLY IF PARSE WON, TO PREVENT SCREWS FROM TYPOS."

define(
  clock_demon,
  (hack
    "AUX"
    ca
    (flg
      <>)),
  #decl
    ((hack)
      hack
      (flg)
      or(
        atom,
        false)),
  cond(
    (,parse_won
      put(
        ,prsvec,
        2,
        <>)
      put(
        ,prsvec,
        3,
        <>)
      mapf(
        <>,
        function(
          (ev
            "AUX"
            (tick
              ctick(
                _ev))),
          #decl
            ((ev)
              cevent
              (tick)
              fix),
          cond(
            (not(
                cflag(
                  _ev))),
            (0_Q(
                _tick)),
            (l_Q(
                _tick,
                0)
              put(
                ,prsvec,
                1,
                ,c_int_X_words)
              cond(
                (type_Q(
                    set(
                      ca,
                      caction(
                        _ev)),
                    offset)
                  dispatch(
                    _ca)),
                (apply(
                    _ca)))),
            (put(
                _ev,
                ,ctick,
                set(
                  tick,
                  _(
                    _tick,
                    1)))
              and(
                0_Q(
                  _tick),
                set(
                  flg,
                  t),
                put(
                  ,prsvec,
                  1,
                  ,c_int_X_words),
                cond(
                  (type_Q(
                      set(
                        ca,
                        caction(
                          _ev)),
                      offset)
                    dispatch(
                      _ca)),
                  (apply(
                      _ca))))))),
        hobjs(
          _hack)))),
  _flg)

gdecl(
  (clocker),
  hack)

define(
  clock_int,
  (cev
    "OPTIONAL"
    (num
      <>)
    (clocker
      ,clocker)),
  #decl
    ((cev)
      cevent
      (num)
      or(
        fix,
        false)
      (clocker)
      hack),
  cond(
    (not(
        memq(
          _cev,
          hobjs(
            _clocker)))
      put(
        _clocker,
        ,hobjs,
        (_cev
          _X
          hobjs(
            _clocker))))),
  cond(
    (_num
      put(
        _cev,
        ,ctick,
        _num))))

setg(
  demons,
  ())

or(
  lookup(
    "COMPILE",
    root(
      )),
  gassigned_Q(
    group_glue),
  add_demon(
    setg(
      clocker,
      chtype(
        [clock_demon
          ()],
        hack))))

define(
  board,
  ("AUX"
    (obj
      2(
        ,prsvec))
    (win
      ,winner)
    (av
      avehicle(
        _win))),
  #decl
    ((obj)
      object
      (win)
      adv
      (av)
      or(
        false,
        object)),
  cond(
    (not(
        memq(
          _obj,
          robjs(
            ,here)))
      tell(
        "The",
        1,
        odesc2(
          _obj),
        "must be on the ground to be boarded.")),
    (trnn(
        _obj,
        ,vehbit)
      cond(
        (_av
          tell(
            "You are already in a",
            1,
            odesc2(
              _obj),
            ", cretin!")),
        (t
          cond(
            (object_action(
                )),
            (tell(
                "You are in the",
                1,
                odesc2(
                  _obj),
                ".")
              put(
                _win,
                ,avehicle,
                _obj)
              put(
                _obj,
                ,ocontents,
                (find_obj(
                    "#####")
                  _X
                  ocontents(
                    _obj)))))))),
    (tell(
        "I suppose you have a theory on boarding",
        1,
        odesc2(
          _obj),
        "s."))))

define(
  unboard,
  ("AUX"
    (obj
      2(
        ,prsvec))
    (win
      ,winner)
    (av
      avehicle(
        _win))),
  #decl
    ((obj)
      object
      (win)
      adv
      (av)
      or(
        false,
        object)),
  cond(
    (_EQ_Q(
        _av,
        _obj)
      cond(
        (object_action(
            )),
        (rtrnn(
            ,here,
            ,rlandbit)
          tell(
            "You are on your own feet again.")
          put(
            _win,
            ,avehicle,
            <>)
          put(
            _obj,
            ,ocontents,
            splice_out(
              find_obj(
                "#####"),
              ocontents(
                _obj)))),
        (tell(
            "You realize, just in time, that disembarking here would probably be\nfatal.")))),
    (tell(
        "You aren't in that!"))))

define(
  goto,
  (rm
    "AUX"
    (win
      ,winner)
    (av
      avehicle(
        ,winner))
    (here
      ,here)
    (lb
      rtrnn(
        _rm,
        ,rlandbit))),
  #decl
    ((here
        rm)
      room
      (win)
      adv
      (av)
      or(
        false,
        object)
      (lb)
      or(
        atom,
        false)),
  cond(
    (or(
        and(
          not(
            _lb),
          or(
            not(
              _av),
            not(
              rtrnn(
                _rm,
                orand(
                  _av))))),
        and(
          rtrnn(
            _here,
            ,rlandbit),
          _lb,
          _av,
          n_EQ_Q(
            orand(
              _av),
            ,rlandbit),
          not(
            rtrnn(
              _rm,
              orand(
                _av)))))
      cond(
        (_av
          tell(
            "You can't go there in a",
            1,
            odesc2(
              _av),
            ".")),
        (tell(
            "You can't go there without a vehicle.")))
      <>),
    (rtrnn(
        _rm,
        ,rmungbit)
      tell(
        rrand(
          _rm))),
    (t
      cond(
        (n_EQ_Q(
            _win,
            ,player)
          remove_object(
            aobj(
              _win))
          insert_object(
            aobj(
              _win),
            _rm)))
      cond(
        (_av
          remove_object(
            _av)
          insert_object(
            _av,
            _rm)))
      put(
        ,winner,
        ,aroom,
        setg(
          here,
          _rm))
      score_room(
        _rm)
      t)))

define(
  backer,
  (),
  tell(
    "He who puts his hand to the plow and looks back is not fit for the\nkingdom of winners.  In any case, \"back\" doesn't work."))

define(
  act_hack,
  (),
  or(
    object_action(
      ),
    t))

define(
  mung_room,
  (rm
    str),
  #decl
    ((rm)
      room
      (str)
      string),
  rtro(
    _rm,
    ,rmungbit),
  put(
    _rm,
    ,rrand,
    _str))

define(
  command,
  ("AUX"
    (pv
      ,prsvec)
    (po
      2(
        _pv))
    (v
      rest(
        member(
          "",
          ,lexv)))
    (hs
      ,here)
    (win
      ,winner)
    (play
      ,player)),
  #decl
    ((po)
      object
      (pv
        v)
      vector
      (hs)
      room
      (win
        play)
      adv),
  cond(
    (n_EQ_Q(
        _win,
        _play)
      tell(
        "You cannot talk through another person!")),
    (trnn(
        _po,
        ,actorbit)
      setg(
        winner,
        orand(
          _po))
      rdcom(
        _v)
      setg(
        winner,
        _play)
      setg(
        here,
        _hs)),
    (tell(
        "You cannot talk to that!"))))
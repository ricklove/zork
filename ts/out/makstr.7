define(CEVENT
  (TICK
    APP
    FLG
    NAME
    "AUX"
    (OBL
      get(INITIAL
        OBLIST);)
    ATM)
  #DECL
    ((TICK)
      FIX
      (APP)
      or(APPLICABLE
        OFFSET);
      (FLG)
      or(ATOM
        FALSE);
      (NAME)
      or(ATOM
        STRING);
      (ATM)
      or(ATOM
        FALSE);)
  cond((type_q(.NAME
        STRING);
      cond((set(ATM
            lookup(.NAME
              .OBL););)
        (T
          set(ATM
            insert(.NAME
              .OBL););));)
    (set(ATM
        .NAME);));
  setg(.ATM
    chtype([.TICK
        .APP
        .FLG
        .ATM]
      CEVENT);););

define(CONS-OBJ
  ("TUPLE"
    OBJS
    "AUX"
    (WINNER
      ,WINNER))
  #DECL
    ((OBJS)
      tuple([REST
          STRING]);
      (WINNER)
      ADV)
  mapf(<>
    function((X
        "AUX"
        (Y
          find_obj(.X);))
      #DECL
        ((Y)
          OBJECT)
      or(memq(.Y
          aobjs(.WINNER););
        take_object(find_obj(.X);
          .WINNER);););
    .OBJS););

define(CEXIT
  (FLID
    RMID
    "OPTIONAL"
    (STR
      <>)
    (FLAG
      <>)
    (FUNCT
      <>)
    "AUX"
    (FVAL
      <>)
    ATM)
  #DECL
    ((STR)
      or(FALSE
        STRING);
      (FLID
        RMID)
      or(ATOM
        STRING);
      (ATM
        FUNCT)
      or(ATOM
        FALSE);
      (FVAL)
      or(APPLICABLE
        FALSE);
      (FLAG)
      or(ATOM
        FALSE);)
  cond((type_q(.FLID
        ATOM);
      set(FLID
        spname(.FLID););));
  set(ATM
    or(lookup(.FLID
        get(FLAG
          OBLIST););
      insert(.FLID
        get(FLAG
          OBLIST););););
  setg(.ATM
    .FLAG);
  chtype(vector(.ATM
      find_room(.RMID);
      .STR
      .FUNCT);
    CEXIT););

define(EXIT
  ("TUPLE"
    PAIRS
    "AUX"
    (DOBL
      ,DIRECTIONS)
    (FROB
      ivector(length(.PAIRS););))
  #DECL
    ((PAIRS)
      tuple([REST
          STRING
          or(NEXIT
            CEXIT
            STRING
            ATOM);]);
      (DIR)
      list([REST
          ATOM]);
      (FROB)
      VECTOR
      (DOBL)
      OBLIST)
  repeat((ATM
      RM
      (F
        .FROB))
    #DECL
      ((ATM)
        or(ATOM
          FALSE);
        (RM)
        or(ROOM
          FALSE);
        (F)
        VECTOR)
    cond((or(and(set(ATM
              lookup(1(.PAIRS);
                .DOBL););
            gassigned_q(.ATM);
            type_q(,.ATM
              DIRECTION);););
        put(.F
          1
          .ATM);
        cond((type_q(2(.PAIRS);
              STRING);
            put(.F
              2
              find_room(2(.PAIRS);););)
          (put(.F
              2
              2(.PAIRS););));
        set(F
          rest(.F
            2););)
      (T
        put(.PAIRS
          1
          error(ILLEGAL-DIRECTION
            1(.PAIRS);););));
    cond((empty_q(set(PAIRS
            rest(.PAIRS
              2);););
        return();)););
  chtype(.FROB
    EXIT););

define(ROOM
  (ID
    D1
    D2
    LIT?
    EX
    "OPTIONAL"
    (OBJS
      ())
    (APP
      <>)
    (VAL
      0)
    (BIT
      ,RLANDBIT)
    "AUX"
    (RM
      find_room(.ID);))
  #DECL
    ((ID)
      or(STRING
        ATOM);
      (D1
        D2)
      STRING
      (LIT?)
      or(ATOM
        FORM
        FALSE);
      (EX)
      EXIT
      (APP)
      or(FORM
        FALSE
        ATOM);
      (VAL
        BIT)
      FIX
      (RM)
      ROOM)
  setg(SCORE-MAX
    _(,SCORE-MAX
      .VAL););
  put(.RM
    ,RBITS
    .BIT);
  put(.RM
    ,RVAL
    .VAL);
  put(.RM
    ,ROBJS
    .OBJS);
  put(.RM
    ,RDESC1
    .D1);
  put(.RM
    ,RDESC2
    .D2);
  put(.RM
    ,REXITS
    .EX);
  put(.RM
    ,RACTION
    cond((type_q(.APP
          FALSE
          FORM);
        <>)
      (.APP)););
  put(.RM
    ,RLIGHT?
    cond((type_q(.LIT?
          FORM);
        <>)
      (T
        .LIT?)););
  mapf(<>
    function((X)
      #DECL
        ((X)
          OBJECT)
      put(.X
        ,OROOM
        .RM););
    robjs(.RM););
  .RM);

define(SOBJECT
  (ID
    STR
    "TUPLE"
    TUP)
  #DECL
    ((ID)
      STRING
      (TUP)
      TUPLE)
  object(.ID
    ""
    .STR
    %
    <>
    <>
    ()
    <>
    _(!.TUP);););

define(AOBJECT
  (ID
    STR
    APP
    "TUPLE"
    TUP)
  #DECL
    ((ID)
      STRING
      (TUP)
      TUPLE
      (APP)
      ATOM)
  object(.ID
    ""
    .STR
    %
    <>
    .APP
    ()
    <>
    _(!.TUP);););

define(OBJECT
  (ID
    DESC1
    DESC2
    DESCO
    APP
    CONTS
    CAN
    FLAGS
    "OPTIONAL"
    (LIGHT?
      0)
    (S1
      0)
    (S2
      0)
    (SIZE
      5)
    (CAPAC
      0))
  #DECL
    ((ID)
      or(ATOM
        STRING);
      (DESC1
        DESC2)
      STRING
      (APP)
      or(FALSE
        FORM
        ATOM);
      (CONTS)
      list([REST
          OBJECT]);
      (CAN)
      or(FALSE
        OBJECT);
      (FLAGS)
      primtype(WORD);
      (SIZE
        CAPAC)
      FIX
      (LIGHT?
        S1
        S2)
      FIX
      (DESCO)
      or(STRING
        FALSE);)
  setg(SCORE-MAX
    _(,SCORE-MAX
      .S1
      .S2););
  or(0_q(.LIGHT?);
    set(FLAGS
      _(.FLAGS
        ,LIGHTBIT);););
  put(put(put(put(put(put(put(put(put(put(put(put(find_obj(.ID);
                          ,ODESC1
                          .DESC1);
                        ,OCAPAC
                        .CAPAC);
                      ,OSIZE
                      .SIZE);
                    ,ODESCO
                    .DESCO);
                  ,OLIGHT?
                  .LIGHT?);
                ,OFLAGS
                .FLAGS);
              ,OFVAL
              .S1);
            ,OTVAL
            .S2);
          ,OCAN
          .CAN);
        ,OCONTENTS
        .CONTS);
      ,ODESC2
      .DESC2);
    ,OACTION
    cond((type_q(.APP
          FALSE
          FORM);
        <>)
      (.APP));););

define(FIND-PREP
  (STR
    "AUX"
    (ATM
      add_word(.STR);))
  #DECL
    ((STR)
      STRING
      (ATM)
      or(FALSE
        ATOM);)
  cond((gassigned_q(.ATM);
      cond((type_q(,.ATM
            PREP);
          ,.ATM)
        (error(NO-PREP!-ERRORS);));)
    (setg(.ATM
        chtype(.ATM
          PREP););)););

define(ADD-ACTION
  (NAM
    STR
    "TUPLE"
    DECL
    "AUX"
    (ATM
      or(lookup(.NAM
          ,ACTIONS);
        insert(.NAM
          ,ACTIONS););))
  #DECL
    ((NAM
        STR)
      STRING
      (DECL)
      tuple([REST
          VECTOR]);
      (ATM)
      ATOM)
  setg(.ATM
    chtype([.ATM
        make_action(!.DECL);
        .STR]
      ACTION););
  .ATM);

define(ADD-DIRECTIONS
  ("TUPLE"
    NMS
    "AUX"
    (DIR
      ,DIRECTIONS)
    ATM)
  #DECL
    ((NMS)
      tuple([REST
          STRING]);
      (DIR)
      OBLIST
      (ATM)
      ATOM)
  mapf(<>
    function((X)
      setg(set(ATM
          or(lookup(.X
              .DIR);
            insert(.X
              .DIR);););
        chtype(.ATM
          DIRECTION);););
    .NMS););

define(DSYNONYM
  (STR
    "TUPLE"
    NMS
    "AUX"
    VAL
    (DIR
      ,DIRECTIONS)
    ATM)
  #DECL
    ((ATM)
      ATOM
      (STR)
      STRING
      (NMS)
      tuple([REST
          STRING]);
      (VAL)
      DIRECTION
      (DIR)
      OBLIST)
  set(VAL
    add_directions(.STR););
  mapf(<>
    function((X)
      setg(set(ATM
          or(lookup(.X
              .DIR);
            insert(.X
              .DIR);););
        .VAL););
    .NMS););

define(VSYNONYM
  (N1
    "TUPLE"
    N2
    "AUX"
    ATM
    VAL)
  #DECL
    ((N1)
      STRING
      (N2)
      tuple([REST
          STRING]);
      (ATM)
      or(FALSE
        ATOM);
      (VAL)
      ANY)
  cond((set(ATM
        lookup(.N1
          ,WORDS););
      set(VAL
        ,.ATM);
      mapf(<>
        function((X)
          setg(add_word(.X);
            .VAL););
        .N2);));
  cond((set(ATM
        lookup(.N1
          ,ACTIONS););
      set(VAL
        ,.ATM);
      mapf(<>
        function((X)
          setg(or(lookup(.X
                ,ACTIONS);
              insert(.X
                ,ACTIONS););
            .VAL););
        .N2);)););

"STUFF FOR ADDING TO VOCABULARY, ADDING TO LISTS (OF DEMONS, FOR EXAMPLE)."

define(ADD-WORD
  (W)
  #DECL
    ((W)
      STRING)
  or(lookup(.W
      ,WORDS);
    insert(.W
      ,WORDS);););

define(ADD-BUZZ
  ("TUPLE"
    W)
  #DECL
    ((W)
      tuple([REST
          STRING]);)
  mapf(<>
    function((X)
      #DECL
        ((X)
          STRING)
      setg(add_word(.X);
        chtype(.X
          BUZZ);););
    .W););

define(ADD-ZORK
  (NM
    "TUPLE"
    W)
  #DECL
    ((NM)
      ATOM
      (W)
      tuple([REST
          STRING]);)
  mapf(<>
    function((X
        "AUX"
        ATM)
      #DECL
        ((X)
          STRING
          (ATM)
          ATOM)
      setg(set(ATM
          add_word(.X););
        chtype(.ATM
          .NM);););
    .W););

define(ADD-OBJECT
  (OBJ
    NAMES
    "OPTIONAL"
    (ADJ
      '[])
    "AUX"
    (OBJS
      ,OBJECT-OBL))
  #DECL
    ((OBJ)
      OBJECT
      (NAMES
        ADJ)
      vector([REST
          STRING]);
      (OBJS)
      OBLIST)
  put(.OBJ
    ,ONAMES
    mapf(,UVECTOR
      function((X)
        #DECL
          ((X)
            STRING)
        or(lookup(.X
            .OBJS);
          insert(.X
            .OBJS);););
      .NAMES););
  put(.OBJ
    ,OADJS
    mapf(,UVECTOR
      function((W)
        add_zork(ADJECTIVE
          .W););
      .ADJ););
  chutype(oadjs(.OBJ);
    ADJECTIVE);
  .OBJ);

define(SYNONYM
  (N1
    "TUPLE"
    N2
    "AUX"
    ATM
    VAL)
  #DECL
    ((N1)
      STRING
      (N2)
      tuple([REST
          STRING]);
      (ATM)
      or(FALSE
        ATOM);
      (VAL)
      ANY)
  cond((set(ATM
        lookup(.N1
          ,WORDS););
      set(VAL
        ,.ATM);
      mapf(<>
        function((X)
          setg(add_word(.X);
            .VAL););
        .N2);)););

define(ADD-ABBREV
  (X
    Y
    "AUX")
  #DECL
    ((X
        Y)
      STRING)
  setg(add_word(.X);
    or(lookup(.Y
        ,WORDS);
      insert(.Y
        ,WORDS););););

define(ADD-DEMON
  (X)
  #DECL
    ((X)
      HACK)
  cond((mapr(<>
        function((Y)
          #DECL
            ((Y)
              list([REST
                  HACK]);)
          cond((eq_q(haction(1(.Y););
                haction(.X););
              put(.Y
                1
                .X);
              mapleave(T);)););
        ,DEMONS);)
    (setg(DEMONS
        (.X
          !,DEMONS));)););

define(ADD-STAR
  (OBJ)
  setg(STARS
    (.OBJ
      !,STARS)););

define(ADD-ACTOR
  (ADV
    "AUX"
    (ACTORS
      ,ACTORS))
  #DECL
    ((ADV)
      ADV
      (ACTORS)
      list([REST
          ADV]);)
  cond((mapf(<>
        function((X)
          #DECL
            ((X)
              ADV)
          cond((eq_q(aobj(.X);
                aobj(.ADV););
              mapleave(T);)););
        .ACTORS);)
    (setg(ACTORS
        (.ADV
          !.ACTORS));));
  .ADV);

define(ADD-DESC
  (OBJ
    STR)
  #DECL
    ((OBJ)
      OBJECT
      (STR)
      STRING)
  put(.OBJ
    ,OREAD
    .STR););

define(SADD-ACTION
  (STR1
    ATM)
  add_action(.STR1
    ""
    [[.STR1
        .ATM]]););

define(1ADD-ACTION
  (STR1
    STR2
    ATM)
  add_action(.STR1
    .STR2
    [OBJ
      [.STR1
        .ATM]]););

define(AADD-ACTION
  (STR1
    STR2
    ATM)
  add_action(.STR1
    .STR2
    [(-1
        AOBJS
        NO-TAKE)
      [.STR1
        .ATM]]););
define(
  cevent,
  (tick
    app
    flg
    name
    "AUX"
    (obl
      get(
        initial,
        oblist))
    atm),
  #decl
    ((tick)
      fix
      (app)
      or(
        applicable,
        offset)
      (flg)
      or(
        atom,
        false)
      (name)
      or(
        atom,
        string)
      (atm)
      or(
        atom,
        false)),
  cond(
    (type_Q(
        _name,
        string)
      cond(
        (set(
            atm,
            lookup(
              _name,
              _obl))),
        (t
          set(
            atm,
            insert(
              _name,
              _obl))))),
    (set(
        atm,
        _name))),
  setg(
    _atm,
    chtype(
      [_tick
        _app
        _flg
        _atm],
      cevent)))

define(
  cons_obj,
  ("TUPLE"
    objs
    "AUX"
    (winner
      ,winner)),
  #decl
    ((objs)
      tuple(
        [rest
          string])
      (winner)
      adv),
  mapf(
    <>,
    function(
      (x
        "AUX"
        (y
          find_obj(
            _x))),
      #decl
        ((y)
          object),
      or(
        memq(
          _y,
          aobjs(
            _winner)),
        take_object(
          find_obj(
            _x),
          _winner))),
    _objs))

define(
  cexit,
  (flid
    rmid
    "OPTIONAL"
    (str
      <>)
    (flag
      <>)
    (funct
      <>)
    "AUX"
    (fval
      <>)
    atm),
  #decl
    ((str)
      or(
        false,
        string)
      (flid
        rmid)
      or(
        atom,
        string)
      (atm
        funct)
      or(
        atom,
        false)
      (fval)
      or(
        applicable,
        false)
      (flag)
      or(
        atom,
        false)),
  cond(
    (type_Q(
        _flid,
        atom)
      set(
        flid,
        spname(
          _flid)))),
  set(
    atm,
    or(
      lookup(
        _flid,
        get(
          flag,
          oblist)),
      insert(
        _flid,
        get(
          flag,
          oblist)))),
  setg(
    _atm,
    _flag),
  chtype(
    vector(
      _atm,
      find_room(
        _rmid),
      _str,
      _funct),
    cexit))

define(
  exit,
  ("TUPLE"
    pairs
    "AUX"
    (dobl
      ,directions)
    (frob
      ivector(
        length(
          _pairs)))),
  #decl
    ((pairs)
      tuple(
        [rest
          string
          or(
            nexit,
            cexit,
            string,
            atom)])
      (dir)
      list(
        [rest
          atom])
      (frob)
      vector
      (dobl)
      oblist),
  repeat(
    (atm
      rm
      (f
        _frob)),
    #decl
      ((atm)
        or(
          atom,
          false)
        (rm)
        or(
          room,
          false)
        (f)
        vector),
    cond(
      (or(
          and(
            set(
              atm,
              lookup(
                1(
                  _pairs),
                _dobl)),
            gassigned_Q(
              _atm),
            type_Q(
              ,_atm,
              direction)))
        put(
          _f,
          1,
          _atm)
        cond(
          (type_Q(
              2(
                _pairs),
              string)
            put(
              _f,
              2,
              find_room(
                2(
                  _pairs)))),
          (put(
              _f,
              2,
              2(
                _pairs))))
        set(
          f,
          rest(
            _f,
            2))),
      (t
        put(
          _pairs,
          1,
          error(
            illegal_direction,
            1(
              _pairs))))),
    cond(
      (empty_Q(
          set(
            pairs,
            rest(
              _pairs,
              2)))
        return(
          )))),
  chtype(
    _frob,
    exit))

define(
  room,
  (id
    d1
    d2
    lit_Q
    ex
    "OPTIONAL"
    (objs
      ())
    (app
      <>)
    (val
      0)
    (bit
      ,rlandbit)
    "AUX"
    (rm
      find_room(
        _id))),
  #decl
    ((id)
      or(
        string,
        atom)
      (d1
        d2)
      string
      (lit_Q)
      or(
        atom,
        form,
        false)
      (ex)
      exit
      (app)
      or(
        form,
        false,
        atom)
      (val
        bit)
      fix
      (rm)
      room),
  setg(
    score_max,
    _(
      ,score_max,
      _val)),
  put(
    _rm,
    ,rbits,
    _bit),
  put(
    _rm,
    ,rval,
    _val),
  put(
    _rm,
    ,robjs,
    _objs),
  put(
    _rm,
    ,rdesc1,
    _d1),
  put(
    _rm,
    ,rdesc2,
    _d2),
  put(
    _rm,
    ,rexits,
    _ex),
  put(
    _rm,
    ,raction,
    cond(
      (type_Q(
          _app,
          false,
          form)
        <>),
      (_app))),
  put(
    _rm,
    ,rlight_Q,
    cond(
      (type_Q(
          _lit_Q,
          form)
        <>),
      (t
        _lit_Q))),
  mapf(
    <>,
    function(
      (x),
      #decl
        ((x)
          object),
      put(
        _x,
        ,oroom,
        _rm)),
    robjs(
      _rm)),
  _rm)

define(
  sobject,
  (id
    str
    "TUPLE"
    tup),
  #decl
    ((id)
      string
      (tup)
      tuple),
  object(
    _id,
    "",
    _str,
    _,
    <>,
    <>,
    (),
    <>,
    _(
      _X_tup)))

define(
  aobject,
  (id
    str
    app
    "TUPLE"
    tup),
  #decl
    ((id)
      string
      (tup)
      tuple
      (app)
      atom),
  object(
    _id,
    "",
    _str,
    _,
    <>,
    _app,
    (),
    <>,
    _(
      _X_tup)))

define(
  object,
  (id
    desc1
    desc2
    desco
    app
    conts
    can
    flags
    "OPTIONAL"
    (light_Q
      0)
    (s1
      0)
    (s2
      0)
    (size
      5)
    (capac
      0)),
  #decl
    ((id)
      or(
        atom,
        string)
      (desc1
        desc2)
      string
      (app)
      or(
        false,
        form,
        atom)
      (conts)
      list(
        [rest
          object])
      (can)
      or(
        false,
        object)
      (flags)
      primtype(
        word)
      (size
        capac)
      fix
      (light_Q
        s1
        s2)
      fix
      (desco)
      or(
        string,
        false)),
  setg(
    score_max,
    _(
      ,score_max,
      _s1,
      _s2)),
  or(
    0_Q(
      _light_Q),
    set(
      flags,
      _(
        _flags,
        ,lightbit))),
  put(
    put(
      put(
        put(
          put(
            put(
              put(
                put(
                  put(
                    put(
                      put(
                        put(
                          find_obj(
                            _id),
                          ,odesc1,
                          _desc1),
                        ,ocapac,
                        _capac),
                      ,osize,
                      _size),
                    ,odesco,
                    _desco),
                  ,olight_Q,
                  _light_Q),
                ,oflags,
                _flags),
              ,ofval,
              _s1),
            ,otval,
            _s2),
          ,ocan,
          _can),
        ,ocontents,
        _conts),
      ,odesc2,
      _desc2),
    ,oaction,
    cond(
      (type_Q(
          _app,
          false,
          form)
        <>),
      (_app))))

define(
  find_prep,
  (str
    "AUX"
    (atm
      add_word(
        _str))),
  #decl
    ((str)
      string
      (atm)
      or(
        false,
        atom)),
  cond(
    (gassigned_Q(
        _atm)
      cond(
        (type_Q(
            ,_atm,
            prep)
          ,_atm),
        (error(
            no_prep_X_errors)))),
    (setg(
        _atm,
        chtype(
          _atm,
          prep)))))

define(
  add_action,
  (nam
    str
    "TUPLE"
    decl
    "AUX"
    (atm
      or(
        lookup(
          _nam,
          ,actions),
        insert(
          _nam,
          ,actions)))),
  #decl
    ((nam
        str)
      string
      (decl)
      tuple(
        [rest
          vector])
      (atm)
      atom),
  setg(
    _atm,
    chtype(
      [_atm
        make_action(
          _X_decl)
        _str],
      action)),
  _atm)

define(
  add_directions,
  ("TUPLE"
    nms
    "AUX"
    (dir
      ,directions)
    atm),
  #decl
    ((nms)
      tuple(
        [rest
          string])
      (dir)
      oblist
      (atm)
      atom),
  mapf(
    <>,
    function(
      (x),
      setg(
        set(
          atm,
          or(
            lookup(
              _x,
              _dir),
            insert(
              _x,
              _dir))),
        chtype(
          _atm,
          direction))),
    _nms))

define(
  dsynonym,
  (str
    "TUPLE"
    nms
    "AUX"
    val
    (dir
      ,directions)
    atm),
  #decl
    ((atm)
      atom
      (str)
      string
      (nms)
      tuple(
        [rest
          string])
      (val)
      direction
      (dir)
      oblist),
  set(
    val,
    add_directions(
      _str)),
  mapf(
    <>,
    function(
      (x),
      setg(
        set(
          atm,
          or(
            lookup(
              _x,
              _dir),
            insert(
              _x,
              _dir))),
        _val)),
    _nms))

define(
  vsynonym,
  (n1
    "TUPLE"
    n2
    "AUX"
    atm
    val),
  #decl
    ((n1)
      string
      (n2)
      tuple(
        [rest
          string])
      (atm)
      or(
        false,
        atom)
      (val)
      any),
  cond(
    (set(
        atm,
        lookup(
          _n1,
          ,words))
      set(
        val,
        ,_atm)
      mapf(
        <>,
        function(
          (x),
          setg(
            add_word(
              _x),
            _val)),
        _n2))),
  cond(
    (set(
        atm,
        lookup(
          _n1,
          ,actions))
      set(
        val,
        ,_atm)
      mapf(
        <>,
        function(
          (x),
          setg(
            or(
              lookup(
                _x,
                ,actions),
              insert(
                _x,
                ,actions)),
            _val)),
        _n2))))

"STUFF FOR ADDING TO VOCABULARY, ADDING TO LISTS (OF DEMONS, FOR EXAMPLE)."

define(
  add_word,
  (w),
  #decl
    ((w)
      string),
  or(
    lookup(
      _w,
      ,words),
    insert(
      _w,
      ,words)))

define(
  add_buzz,
  ("TUPLE"
    w),
  #decl
    ((w)
      tuple(
        [rest
          string])),
  mapf(
    <>,
    function(
      (x),
      #decl
        ((x)
          string),
      setg(
        add_word(
          _x),
        chtype(
          _x,
          buzz))),
    _w))

define(
  add_zork,
  (nm
    "TUPLE"
    w),
  #decl
    ((nm)
      atom
      (w)
      tuple(
        [rest
          string])),
  mapf(
    <>,
    function(
      (x
        "AUX"
        atm),
      #decl
        ((x)
          string
          (atm)
          atom),
      setg(
        set(
          atm,
          add_word(
            _x)),
        chtype(
          _atm,
          _nm))),
    _w))

define(
  add_object,
  (obj
    names
    "OPTIONAL"
    (adj
      () => [])
    "AUX"
    (objs
      ,object_obl)),
  #decl
    ((obj)
      object
      (names
        adj)
      vector(
        [rest
          string])
      (objs)
      oblist),
  put(
    _obj,
    ,onames,
    mapf(
      ,uvector,
      function(
        (x),
        #decl
          ((x)
            string),
        or(
          lookup(
            _x,
            _objs),
          insert(
            _x,
            _objs))),
      _names)),
  put(
    _obj,
    ,oadjs,
    mapf(
      ,uvector,
      function(
        (w),
        add_zork(
          adjective,
          _w)),
      _adj)),
  chutype(
    oadjs(
      _obj),
    adjective),
  _obj)

define(
  synonym,
  (n1
    "TUPLE"
    n2
    "AUX"
    atm
    val),
  #decl
    ((n1)
      string
      (n2)
      tuple(
        [rest
          string])
      (atm)
      or(
        false,
        atom)
      (val)
      any),
  cond(
    (set(
        atm,
        lookup(
          _n1,
          ,words))
      set(
        val,
        ,_atm)
      mapf(
        <>,
        function(
          (x),
          setg(
            add_word(
              _x),
            _val)),
        _n2))))

define(
  add_abbrev,
  (x
    y
    "AUX"),
  #decl
    ((x
        y)
      string),
  setg(
    add_word(
      _x),
    or(
      lookup(
        _y,
        ,words),
      insert(
        _y,
        ,words))))

define(
  add_demon,
  (x),
  #decl
    ((x)
      hack),
  cond(
    (mapr(
        <>,
        function(
          (y),
          #decl
            ((y)
              list(
                [rest
                  hack])),
          cond(
            (_EQ_Q(
                haction(
                  1(
                    _y)),
                haction(
                  _x))
              put(
                _y,
                1,
                _x)
              mapleave(
                t)))),
        ,demons)),
    (setg(
        demons,
        (_x
          _X
          ,demons)))))

define(
  add_star,
  (obj),
  setg(
    stars,
    (_obj
      _X
      ,stars)))

define(
  add_actor,
  (adv
    "AUX"
    (actors
      ,actors)),
  #decl
    ((adv)
      adv
      (actors)
      list(
        [rest
          adv])),
  cond(
    (mapf(
        <>,
        function(
          (x),
          #decl
            ((x)
              adv),
          cond(
            (_EQ_Q(
                aobj(
                  _x),
                aobj(
                  _adv))
              mapleave(
                t)))),
        _actors)),
    (setg(
        actors,
        (_adv
          _X_actors)))),
  _adv)

define(
  add_desc,
  (obj
    str),
  #decl
    ((obj)
      object
      (str)
      string),
  put(
    _obj,
    ,oread,
    _str))

define(
  sadd_action,
  (str1
    atm),
  add_action(
    _str1,
    "",
    [[_str1
        _atm]]))

define(
  1add_action,
  (str1
    str2
    atm),
  add_action(
    _str1,
    _str2,
    [obj
      [_str1
        _atm]]))

define(
  aadd_action,
  (str1
    str2
    atm),
  add_action(
    _str1,
    _str2,
    [(_1
        aobjs
        no_take)
      [_str1
        _atm]]))
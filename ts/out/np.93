setg(WORDS
  or(get(WORDS
      OBLIST);
    moblist(WORDS
      23);););

setg(OBJECT-OBL
  or(get(OBJECTS
      OBLIST);
    moblist(OBJECTS
      23);););

setg(ACTIONS
  moblist(ACTIONS
    17););

setg(ORPHANS
  [<>
    <>
    <>
    <>
    <>]);

cond((or(lookup("COMPILE"
        root(););
      gassigned_q(GROUP-GLUE););)
  (setg(PREPVEC
      [chtype([find_prep("WITH");
            find_obj("#####");]
          PHRASE);
        chtype([find_prep("WITH");
            find_obj("#####");]
          PHRASE);]);
    setg(PREP2VEC
      [chtype([find_prep("WITH");
            find_obj("#####");]
          PHRASE);
        chtype([find_prep("WITH");
            find_obj("#####");]
          PHRASE);]);));

define(SPARSE
  SPAROUT
  (SV
    VB
    "AUX"
    (WORDS
      ,WORDS)
    (OBJOB
      ,OBJECT-OBL)
    (PV
      ,PRSVEC)
    (PVR
      put(put(rest(.PV);
          1
          <>);
        2
        <>);)
    (ACTIONS
      ,ACTIONS)
    (DIRS
      ,DIRECTIONS)
    (ORPH
      ,ORPHANS)
    (ORFL
      oflag(.ORPH);)
    (PRV
      ,PREPVEC)
    (HERE
      ,HERE)
    (ACTION
      <>)
    (PREP
      <>)
    NPREP
    (ADJ
      <>)
    ATM
    AVAL
    OBJ
    PPREP
    LOBJ
    VAL)
  #DECL
    ((SV)
      vector([REST
          STRING]);
      (VB
        ORFL)
      or(ATOM
        FALSE);
      (ACTIONS
        WORDS
        OBJOB
        DIRS)
      OBLIST
      (PV
        ORPH
        PRV
        PVR)
      VECTOR
      (ATM)
      or(ATOM
        FALSE);
      (HERE)
      ROOM
      (ACTION)
      or(FALSE
        ACTION);
      (NPREP
        PREP)
      or(FALSE
        PREP);
      (ADJ)
      or(FALSE
        ADJECTIVE);
      (AVAL)
      ANY
      (LOBJ)
      ANY
      (OBJ)
      or(FALSE
        OBJECT);
      (PPREP)
      PHRASE)
  set(VAL
    mapf(<>
      function((X)
        #DECL
          ((X)
            STRING)
        cond((empty_q(.X);
            mapleave(T);)
          (and(not(.ACTION);
              set(ATM
                lookup(.X
                  .ACTIONS);););
            set(ACTION
              ,.ATM);)
          (and(not(.ACTION);
              set(ATM
                lookup(.X
                  .DIRS);););
            put(.PV
              1
              ,WALK!-WORDS);
            put(.PV
              2
              ,.ATM);
            return(WIN
              .SPAROUT);)
          (and(set(ATM
                lookup(.X
                  .WORDS););
              cond((type_q(set(AVAL
                      ,.ATM);
                    PREP);
                  cond((.PREP
                      or(.VB
                        tell("Double preposition?"
                          0););
                      mapleave(<>);)
                    (set(PREP
                        .AVAL);));)
                (type_q(.AVAL
                    ADJECTIVE);
                  set(ADJ
                    .AVAL);
                  not(and(.ORFL
                      set(ATM
                        oname(.ORPH););
                      set(X
                        spname(.ATM););););)
                (T)););)
          (set(ATM
              lookup(.X
                .OBJOB););
            cond((set(OBJ
                  get_object(.ATM
                    .ADJ););
                and(empty_q(.PVR);
                  or(.VB
                    tell("Too many objects specified?"
                      0););
                  mapleave(<>););
                put(.PVR
                  1
                  cond((.PREP
                      set(PPREP
                        1(.PRV););
                      set(PRV
                        rest(.PRV););
                      put(.PPREP
                        1
                        .PREP);
                      set(PREP
                        <>);
                      put(.PPREP
                        2
                        .OBJ);)
                    (.OBJ)););
                set(PVR
                  rest(.PVR););)
              (T
                cond((empty_q(.OBJ);
                    or(.VB
                      cond((lit_q(.HERE);
                          tell("I can't see a"
                            0);
                          cond((.ADJ
                              tell(" "
                                0
                                prstr(chtype(.ADJ
                                    ATOM);););));
                          tell(" "
                            0
                            prstr(.ATM);
                            " here.");)
                        (tell("It is too dark in here to see."
                            0);)););)
                  (eq_q(.OBJ
                      ,NEFALS2);
                    or(.VB
                      tell("I can't reach that from inside the "
                        0
                        odesc2(avehicle(,WINNER););
                        "."););)
                  (or(.VB
                      tell("Which "
                        0
                        prstr(.ATM);
                        "?"););
                    orphan(T
                      or(.ACTION
                        and(.ORFL
                          overb(.ORPH);););
                      2(.PV);
                      .PREP
                      .ATM);));
                mapleave(<>);));
            set(ADJ
              <>);
            T)
          (or(.VB
              tell("I don't know the word "
                0
                .X););
            mapleave(<>);)););
      .SV););
  cond((.VAL
      cond((and(not(.ACTION);
            not(set(ACTION
                and(.ORFL
                  overb(.ORPH);););););
          or(.VB
            cond((type_q(2(.PV);
                  OBJECT);
                tell("What should I do with the "
                  0
                  odesc2(2(.PV););
                  "?");)
              (tell("Huh?"
                  0);)););
          orphan(T
            <>
            2(.PV););
          <>)
        (and(put(.PV
              1
              .ACTION);
            .ADJ);
          or(.VB
            tell("Dangling adjective?"
              0););
          <>)
        (and(.ORFL
            set(NPREP
              oprep(.ORPH););
            set(OBJ
              2(.PV););
            put(set(PPREP
                1(.PRV););
              1
              .NPREP);
            put(.PPREP
              2
              .OBJ);
            cond((set(OBJ
                  oslot1(.ORPH););
                put(.PV
                  2
                  .OBJ);
                put(.PV
                  3
                  .PPREP);)
              (put(.PV
                  2
                  .PPREP);));
            <>);)
        (.PREP
          and(type_q(set(LOBJ
                1(back(.PVR);););
              OBJECT);
            top(put(back(.PVR);
                1
                put(put(1(.PRV);
                    1
                    .PREP);
                  2
                  .LOBJ););););)
        (.PV));)););

define(SP
  (STR)
  parse(lex(.STR);
    <>););

define(ORPHAN
  ("OPTIONAL"
    (FLAG
      <>)
    (ACTION
      <>)
    (SLOT1
      <>)
    (PREP
      <>)
    (NAME
      <>))
  #DECL
    ((FLAG)
      or(ATOM
        FALSE);
      (NAME)
      or(ATOM
        FALSE);)
  put(put(put(put(put(,ORPHANS
            ,ONAME
            .NAME);
          ,OPREP
          .PREP);
        ,OSLOT1
        .SLOT1);
      ,OVERB
      .ACTION);
    ,OFLAG
    .FLAG););

define(SYN-MATCH
  (PV
    "AUX"
    (ACTION
      1(.PV);)
    (OBJS
      rest(.PV);)
    (O1
      1(.OBJS);)
    (O2
      2(.OBJS);)
    (DFORCE
      <>)
    (DRIVE
      <>)
    (GWIM
      <>)
    SYNN)
  #DECL
    ((ACTION)
      ACTION
      (PV
        OBJS)
      VECTOR
      (DRIVE
        DFORCE)
      or(FALSE
        SYNTAX);
      (O1
        O2)
      or(FALSE
        OBJECT
        PHRASE);
      (SYNN)
      VARG
      (GWIM)
      or(FALSE
        OBJECT);)
  cond((mapf(<>
        function((SYN)
          #DECL
            ((SYN)
              SYNTAX)
          cond((syn_equal(syn1(.SYN);
                .O1);
              cond((syn_equal(syn2(.SYN);
                    .O2);
                  and(sflip(.SYN);
                    put(.OBJS
                      1
                      .O2);
                    put(.OBJS
                      2
                      .O1););
                  mapleave(take_it-or-leave-it(.SYN
                      put(.PV
                        1
                        sfcn(.SYN););););)
                (not(.O2);
                  cond((sdriver(.SYN);
                      set(DFORCE
                        .SYN);)
                    (set(DRIVE
                        .SYN);));
                  <>));)
            (not(.O1);
              cond((sdriver(.SYN);
                  set(DFORCE
                    .SYN);)
                (set(DRIVE
                    .SYN);));
              <>)););
        vdecl(.ACTION););)
    (set(DRIVE
        or(.DFORCE
          .DRIVE););
      cond((and(set(SYNN
              syn1(.DRIVE););
            not(.O1);
            not(0_q(vbit(.SYNN);););
            not(orfeo(.SYNN
                .OBJS););
            not(set(O1
                set(GWIM
                  gwim_slot(1
                    .SYNN
                    .ACTION
                    .OBJS);););););
          orphan(T
            .ACTION
            <>
            vprep(.SYNN););
          ortell(.SYNN
            .ACTION
            .GWIM);)
        (and(set(SYNN
              syn2(.DRIVE););
            not(.O2);
            not(0_q(vbit(.SYNN);););
            not(gwim_slot(2
                .SYNN
                .ACTION
                .OBJS);););
          orphan(T
            .ACTION
            .O1
            vprep(.SYNN););
          ortell(.SYNN
            .ACTION
            .GWIM);)
        (take_it-or-leave-it(.DRIVE
            put(.PV
              1
              sfcn(.DRIVE);););));)
    (tell("I can't make sense out of that."
        0);
      <>)););

define(TAKE-IT-OR-LEAVE-IT
  (SYN
    PV
    "AUX"
    (PV1
      2(.PV);)
    (PV2
      3(.PV);)
    OBJ
    VARG)
  #DECL
    ((SYN)
      SYNTAX
      (PV)
      VECTOR
      (PV1
        PV2)
      or(FALSE
        OBJECT
        PHRASE);
      (OBJ)
      or(FALSE
        OBJECT);
      (VARG)
      VARG)
  put(.PV
    2
    set(OBJ
      cond((type_q(.PV1
            OBJECT);
          .PV1)
        (type_q(.PV1
            PHRASE);
          2(.PV1);));););
  cond((vtrnn(set(VARG
          syn1(.SYN););
        ,VRBIT);
      take_it(.OBJ
        .PV
        .VARG);));
  put(.PV
    3
    set(OBJ
      cond((type_q(.PV2
            OBJECT);
          .PV2)
        (type_q(.PV2
            PHRASE);
          2(.PV2);));););
  cond((vtrnn(set(VARG
          syn2(.SYN););
        ,VRBIT);
      take_it(.OBJ
        .PV
        .VARG);));
  T);

define(TAKE-IT
  (OBJ
    VEC
    VRB
    "AUX"
    (SAV1
      1(.VEC);)
    (SAV2
      2(.VEC);))
  #DECL
    ((OBJ)
      OBJECT
      (VEC)
      VECTOR
      (SAV1)
      VERB
      (SAV2)
      or(FALSE
        OBJECT);
      (VRB)
      VARG)
  cond((and(search_list(oid(.OBJ);
          robjs(,HERE);
          <>);
        or(can_take_q(.OBJ);
          not(vtrnn(.VRB
              ,VTBIT););););
      put(.VEC
        1
        ,TAKE!-WORDS);
      put(.VEC
        2
        .OBJ);
      take(T);
      put(.VEC
        1
        .SAV1);
      put(.VEC
        2
        .SAV2);)););

define(ORFEO
  (SYN
    OBJS
    "AUX"
    (ORPH
      ,ORPHANS)
    (ORFL
      oflag(.ORPH);)
    SLOT1)
  #DECL
    ((SYN)
      VARG
      (OBJS
        ORPH)
      VECTOR
      (ORFL)
      or(ATOM
        FALSE);
      (SLOT1)
      or(FALSE
        PHRASE
        OBJECT);)
  cond((not(.ORFL);
      <>)
    (set(SLOT1
        oslot1(.ORPH););
      and(syn_equal(.SYN
          .SLOT1);
        put(.OBJS
          1
          .SLOT1););)););

define(ORTELL
  (VARG
    ACTION
    GWIM
    "AUX"
    (PREP
      vprep(.VARG);)
    SP)
  #DECL
    ((VARG)
      VARG
      (ACTION)
      ACTION
      (PREP)
      or(FALSE
        PREP);
      (SP)
      STRING
      (GWIM)
      or(FALSE
        OBJECT);)
  cond((.PREP
      and(.GWIM
        tell(vstr(.ACTION);
          0
          " ");
        tell(odesc2(.GWIM);
          0
          " "););
      tell(prstr(chtype(.PREP
            ATOM););
        0
        " what?");)
    (tell(vstr(.ACTION);
        0
        " what?");));
  <>);

define(PRSTR
  (ATM
    "AUX"
    SP)
  #DECL
    ((ATM)
      ATOM
      (SP)
      STRING)
  foostr(set(SP
      spname(.ATM););
    back(,SCRSTR
      length(.SP););
    <>););

define(FOOSTR
  (NAM
    STR
    "OPTIONAL"
    (1ST
      T))
  #DECL
    ((STR
        NAM)
      STRING
      (1ST)
      or(ATOM
        FALSE);)
  mapr(<>
    function((X
        Y)
      #DECL
        ((X
            Y)
          STRING)
      cond((and(.1ST
            eq_q(.X
              .NAM););
          put(.Y
            1
            1(.X););)
        (put(.Y
            1
            chtype(_(32
                ascii(1(.X);););
              CHARACTER););)););
    .NAM
    .STR);
  .STR);

define(GWIM-SLOT
  (FX
    VARG
    ACTION
    OBJS
    "AUX"
    OBJ)
  #DECL
    ((FX)
      FIX
      (VARG)
      VARG
      (ACTION)
      ACTION
      (OBJS)
      VECTOR
      (OBJ)
      or(FALSE
        OBJECT);)
  cond((set(OBJ
        gwim(vbit(.VARG);
          .VARG
          .ACTION););
      put(.OBJS
        .FX
        .OBJ);
      .OBJ)););

"GET WHAT I MEAN - GWIM  TAKES BIT TO CHECK AND WHERE TO CHECK AND WINS TOTALLY"

define(GWIM
  (BIT
    FWORD
    ACTION
    "AUX"
    (AOBJ
      vtrnn(.FWORD
        ,VABIT);)
    (NTAKE
      vtrnn(.FWORD
        ,VTBIT);)
    (ROBJ
      vtrnn(.FWORD
        ,VRBIT);)
    (OBJ
      <>)
    NOBJ
    (PV
      ,PRSVEC)
    SAVOBJ
    (AV
      avehicle(,WINNER);)
    SF)
  #DECL
    ((BIT)
      FIX
      (NTAKE
        ROBJ
        AOBJ)
      or(ATOM
        FALSE);
      (OBJ
        NOBJ
        AV)
      or(OBJECT
        FALSE);
      (PV)
      VECTOR
      (SAVOBJ)
      or(FALSE
        OBJECT
        PHRASE);
      (FWORD)
      VARG
      (ACTION)
      ACTION)
  and(.AOBJ
    set(OBJ
      fwim(.BIT
        aobjs(,WINNER);
        .NTAKE);););
  cond((.ROBJ
      cond((and(set(NOBJ
              fwim(.BIT
                robjs(,HERE);
                .NTAKE););
            or(not(.AV);
              eq_q(.AV
                .NOBJ);
              memq(.NOBJ
                ocontents(.AV););
              trnn(.NOBJ
                ,FINDMEBIT);););
          cond((and(or(set(SAVOBJ
                    2(.PV););
                  T);
                not(.OBJ);
                or(set(SF
                    1(.PV););
                  T);
                put(.PV
                  1
                  ,TAKE!-WORDS);
                put(.PV
                  2
                  .NOBJ);
                or(eq_q(.ACTION
                    1(.PV););
                  .NTAKE
                  take(););
                put(.PV
                  2
                  .SAVOBJ);
                put(.PV
                  1
                  .SF);
                .NOBJ);)
            (put(.PV
                2
                .SAVOBJ);
              <>));)
        (or(.NOBJ
            not(empty_q(.NOBJ);););
          ,NEFALS)
        (.OBJ));)
    (.OBJ)););

// [ON (,BIT ,BIT ,BIT ROBJS NO-TAKE ...) [ATOM!-WORDS <FCN>] DRIVER]

define(MAKE-ACTION
  ("TUPLE"
    SPECS
    "AUX"
    VV
    SUM
    (PREP
      <>)
    ATM)
  chtype(mapf(,UVECTOR
      function((SP
          "AUX"
          (SYN
            ivector(5
              <>);)
          (WHR
            1))
        #DECL
          ((SP)
            VECTOR
            (SYN)
            VECTOR
            (WHR)
            FIX)
        mapf(<>
          function((ITM)
            cond((type_q(.ITM
                  STRING);
                set(PREP
                  find_prep(.ITM););)
              (and(eq_q(.ITM
                    OBJ);
                  set(ITM
                    '(-1));
                  <>);)
              (type_q(.ITM
                  LIST);
                set(VV
                  ivector(3););
                put(.VV
                  1
                  1(.ITM););
                put(.VV
                  2
                  .PREP);
                set(SUM
                  0);
                set(PREP
                  <>);
                and(memq(AOBJS
                    .ITM);
                  set(SUM
                    _(.SUM
                      ,VABIT);););
                and(memq(ROBJS
                    .ITM);
                  set(SUM
                    _(.SUM
                      ,VRBIT);););
                and(memq(NO-TAKE
                    .ITM);
                  set(SUM
                    _(.SUM
                      ,VTBIT);););
                and(memq(=
                    .ITM);
                  set(SUM
                    _(.SUM
                      ,VXBIT);););
                put(.VV
                  3
                  .SUM);
                put(.SYN
                  .WHR
                  chtype(.VV
                    VARG););
                set(WHR
                  _(.WHR
                    1););)
              (type_q(.ITM
                  VECTOR);
                cond((gassigned_q(set(ATM
                        add_word(1(.ITM););););
                    put(.SYN
                      ,SFCN
                      ,.ATM);)
                  (put(.SYN
                      ,SFCN
                      setg(set(ATM
                          add_word(1(.ITM);););
                        chtype([.ATM
                            2(.ITM);]
                          VERB);););));)
              (eq_q(.ITM
                  DRIVER);
                put(.SYN
                  ,SDRIVER
                  T);)
              (eq_q(.ITM
                  FLIP);
                put(.SYN
                  ,SFLIP
                  T);)););
          .SP);
        or(syn1(.SYN);
          put(.SYN
            ,SYN1
            ,EVARG););
        or(syn2(.SYN);
          put(.SYN
            ,SYN2
            ,EVARG););
        chtype(.SYN
          SYNTAX););
      .SPECS);
    VSPEC););

setg(EVARG
  chtype([0
      <>
      0]
    VARG););

define(SYN-EQUAL
  (VARG
    POBJ
    "AUX"
    (VBIT
      vbit(.VARG);))
  #DECL
    ((VARG)
      VARG
      (POBJ)
      or(FALSE
        PHRASE
        OBJECT);
      (VBIT)
      FIX)
  cond((type_q(.POBJ
        PHRASE);
      and(eq_q(vprep(.VARG);
          1(.POBJ););
        or(not(vtrnn(.VARG
              ,VXBIT););
          trnn(2(.POBJ);
            .VBIT);););)
    (type_q(.POBJ
        OBJECT);
      and(not(vprep(.VARG););
        or(not(vtrnn(.VARG
              ,VXBIT););
          trnn(.POBJ
            .VBIT);););)
    (and(not(.POBJ);
        0_q(.VBIT););)););

setg(DIRECTIONS
  moblist(DIRECTIONS););

define(EPARSE
  (PV
    VB
    "AUX"
    VAL)
  #DECL
    ((VAL)
      ANY
      (PV)
      vector([REST
          STRING]);
      (VB)
      or(ATOM
        FALSE);)
  cond((set(VAL
        sparse(.PV
          .VB););
      cond((or(eq_q(.VAL
              WIN);
            syn_match(.VAL););
          orphan(<>);)
        (or(.VB
            tell(""););
          <>));)
    (or(.VB
        tell(""););
      <>)););

setg(SCRSTR
  rest(istring(5);
    5););

setg(SSV
  ivector(10
    <>););

"GET-OBJECT:  TAKES ATOM (FROM OBJECTS OBLIST), VERBOSITY FLAG.  GROVELS OVER: ,STARS; ,HERE; ,WINNER LOOKING FOR OBJECT (LOOKS DOWN TO ONE LEVEL OF CONTAINMENT).  RETURNS <> IF NOT FOUND OR FOUND MORE THAN ONE, THE OBJECT OTHERWISE."

define(GET-OBJECT
  GET-OBJ
  (OBJNAM
    ADJ
    "AUX"
    OBJ
    (OOBJ
      <>)
    (HERE
      ,HERE)
    (AV
      avehicle(,WINNER);)
    (CHOMP
      <>))
  #DECL
    ((OOBJ
        OBJ
        AV)
      or(OBJECT
        FALSE);
      (OBJNAM)
      ATOM
      (HERE)
      ROOM
      (ADJ)
      or(ADJECTIVE
        FALSE);
      (CHOMP)
      or(ATOM
        FALSE);
      (OBJL)
      or(FALSE
        list([REST
            OBJECT]););)
  cond((set(OBJ
        search_list(.OBJNAM
          ,STARS
          .ADJ););
      set(OOBJ
        .OBJ);)
    (not(empty_q(.OBJ););
      return(,NEFALS
        .GET-OBJ);));
  cond((and(lit_q(.HERE);
        set(OBJ
          search_list(.OBJNAM
            robjs(,HERE);
            .ADJ);););
      cond((and(.AV
            neq_q(.OBJ
              .AV);
            not(memq(.OBJ
                ocontents(.AV);););
            not(trnn(.OBJ
                ,FINDMEBIT);););
          set(CHOMP
            T);)
        (.OOBJ
          return(,NEFALS
            .GET-OBJ);)
        (set(OOBJ
            .OBJ);));)
    (and(not(.OBJ);
        not(empty_q(.OBJ);););
      return(,NEFALS
        .GET-OBJ);));
  cond((.AV
      cond((set(OBJ
            search_list(.OBJNAM
              ocontents(.AV);
              .ADJ););
          set(CHOMP
            <>);
          set(OOBJ
            .OBJ);)
        (not(empty_q(.OBJ););
          return(,NEFALS
            .GET-OBJ);));));
  cond((set(OBJ
        search_list(.OBJNAM
          aobjs(,WINNER);
          .ADJ););
      cond((.OOBJ
          ,NEFALS)
        (.OBJ));)
    (not(empty_q(.OBJ););
      ,NEFALS)
    (.CHOMP
      ,NEFALS2)
    (.OOBJ)););

"SEARCH-LIST:  TAKES OBJECT NAME, LIST OF OBJECTS, AND VERBOSITY. IF FINDS ONE FROB UNDER THAT NAME ON LIST, RETURNS IT.  SEARCH IS TO ONE LEVEL OF CONTAINMENT."

setg(NEFALS
  #FALSE
    (1));

setg(NEFALS2
  #FALSE
    (2));

define(SEARCH-LIST
  SL
  (OBJNAM
    SLIST
    ADJ
    "OPTIONAL"
    (FIRST?
      T)
    "AUX"
    (OOBJ
      <>)
    (NEFALS
      ,NEFALS)
    NOBJ)
  #DECL
    ((OBJNAM)
      ATOM
      (SLIST)
      list([REST
          OBJECT]);
      (OOBJ
        NOBJ)
      or(FALSE
        OBJECT);
      (ADJ)
      or(FALSE
        ADJECTIVE);
      (FIRST?)
      or(ATOM
        FALSE);
      (NEFALS)
      FALSE)
  mapf(<>
    function((OBJ)
      #DECL
        ((OBJ)
          OBJECT)
      cond((this_it_q(.OBJNAM
            .OBJ
            .ADJ);
          cond((.OOBJ
              return(.NEFALS
                .SL);)
            (set(OOBJ
                .OBJ);));));
      cond((and(ovis_q(.OBJ);
            or(oopen_q(.OBJ);
              transparent_q(.OBJ););
            or(.FIRST?
              trnn(.OBJ
                ,SEARCHBIT);););
          cond((set(NOBJ
                search_list(.OBJNAM
                  ocontents(.OBJ);
                  .ADJ
                  <>););
              cond((.OOBJ
                  return(.NEFALS
                    .SL);)
                (set(OOBJ
                    .NOBJ);));)
            (eq_q(.NOBJ
                .NEFALS);
              return(.NEFALS
                .SL);));)););
    .SLIST);
  .OOBJ);

"FWIM:  TAKE LIST OF FROBS, FIND ONE THAT CAN BE MANIPULATED (VISIBLE AND TAKEABLE, OR VISIBLE AND IN SOMETHING THAT'S VISIBLE AND OPEN)"

define(FWIM
  DWIM
  (BIT
    OBJS
    NO-TAKE
    "AUX"
    (NOBJ
      <>))
  #DECL
    ((NO-TAKE)
      or(ATOM
        FALSE);
      (BIT)
      FIX
      (OBJS)
      list([REST
          OBJECT]);
      (NOBJ)
      or(FALSE
        OBJECT);)
  mapf(<>
    function((X)
      #DECL
        ((X)
          OBJECT)
      cond((and(ovis_q(.X);
            or(.NO-TAKE
              can_take_q(.X););
            trnn(.X
              .BIT););
          cond((.NOBJ
              return(,NEFALS
                .DWIM);));
          set(NOBJ
            .X);));
      cond((and(ovis_q(.X);
            oopen_q(.X););
          mapf(<>
            function((X)
              #DECL
                ((X)
                  OBJECT)
              cond((and(ovis_q(.X);
                    trnn(.X
                      .BIT););
                  cond((.NOBJ
                      return(,NEFALS
                        .DWIM);)
                    (set(NOBJ
                        .X);));)););
            ocontents(.X););)););
    .OBJS);
  .NOBJ);